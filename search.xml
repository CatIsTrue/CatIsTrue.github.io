<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ explicit关键字什么时候用？</title>
    <url>/posts/e7024663.html</url>
    <content><![CDATA[<p>看到项目代码里的构造函数，有时候用<code>explicit</code>,有时候不用，引发了我的思考，到底这个关键字什么时候用呢？</p>
<p>带着这个问题，我查看了一些资料。</p>
<p>比较官方的解释是：</p>
<p><code>explicit</code>关键字用于<strong>禁止构造函数的隐式类型转换</strong>。</p>
<p>当构造函数被标记为<code>explicit</code>时，编译器不会自动使用该构造函数进行隐式转换。</p>
<hr>
<p>听得似懂非懂。</p>
<p>还是找些具体的例子看看来说吧。</p>
<h2 id="没有explicit导致的重载决议歧义错误"><a href="#没有explicit导致的重载决议歧义错误" class="headerlink" title="没有explicit导致的重载决议歧义错误"></a>没有explicit导致的重载决议歧义错误</h2><p>C++ 有一个默认特性：如果一个构造函数只接受一个参数，编译器会默认认为它定义了一种“隐式转换路径”。</p>
<p>在这个例子里，由于单参数构造函数没有explicit，所以没有禁止隐式转换，导致重载决议歧义错误，出现编译错误。<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// errDemo.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cents</span> &#123;</span><br><span class="line">    <span class="type">int</span> cents_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cents</span>(<span class="type">int</span> c) : <span class="built_in">cents_</span>(c) &#123; std::cout &lt;&lt; <span class="string">&quot;Cents: &quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dollar</span> &#123;</span><br><span class="line">    <span class="type">int</span> dollar_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dollar</span>(<span class="type">int</span> c) : <span class="built_in">dollar_</span>(c) &#123; std::cout &lt;&lt; <span class="string">&quot;Dollar: &quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">payBill</span><span class="params">(Cents amount)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Paying with cents\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">payBill</span><span class="params">(Dollar amount)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Paying with dollars\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">payBill</span>(<span class="number">500</span>);   <span class="comment">// ❌ 编译错误：ambiguous call</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于两个函数的匹配程度完全相同，都需要一次用户定义的隐式转换， 编译器无法确定选择哪一个，导致编译错误<br><img src="/images/image-17.png" alt="重载决议歧义错误"></p>
<p>这时，我们通过使用 explicit，要求必须明确意图的进行调用，于是修改上面的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 构造函数前加explicit关键字</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Cents</span><span class="params">(<span class="type">int</span> c)</span> : cents_(c) &#123;</span> std::cout &lt;&lt; <span class="string">&quot;Cents: &quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;  <span class="comment">// 禁止隐式转换</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Dollar</span><span class="params">(<span class="type">int</span> c)</span> : dollar_(c) &#123;</span> std::cout &lt;&lt; <span class="string">&quot;Dollar: &quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;  <span class="comment">// 禁止隐式转换</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.明确调用意图</span></span><br><span class="line"><span class="comment">// payBill(500);           // ❌ 此时会报编译错误：没有匹配的重载</span></span><br><span class="line">                           <span class="comment">//  error: no matching function for call to ‘payBill(int)</span></span><br><span class="line"><span class="built_in">payBill</span>(<span class="built_in">Cents</span>(<span class="number">500</span>));    <span class="comment">// ✅ 必须显式转换， 明确意图</span></span><br><span class="line"><span class="built_in">payBill</span>(<span class="built_in">Dollar</span>(<span class="number">500</span>));   <span class="comment">// ✅ 必须显式转换， 明确意图</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/image-18.png" alt="明确意图，显式转换"></p>
<hr>
<h2 id="没有explicit导致的性能陷阱"><a href="#没有explicit导致的性能陷阱" class="headerlink" title="没有explicit导致的性能陷阱"></a>没有explicit导致的性能陷阱</h2><p>在性能关键、资源敏感的软件开发中，没有使用<code>explicit</code>，超出预期的隐式转换，可能无意间消耗内存资源。<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line">    <span class="type">double</span>* data;</span><br><span class="line">    <span class="type">size_t</span> size_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Matrix</span>(<span class="type">size_t</span> size) : <span class="built_in">size_</span>(size) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">double</span>[size * size];  <span class="comment">// 昂贵的内存分配！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compute</span><span class="params">(<span class="type">const</span> Matrix&amp; m)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 性能陷阱</span></span><br><span class="line"><span class="built_in">compute</span>(<span class="number">1000</span>);  <span class="comment">// 意外创建了1000x1000的矩阵！</span></span><br></pre></td></tr></table></figure>

<p>这时，通过使用 explicit，要求必须明确意图的进行调用，修改上面的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 构造函数前加explicit关键字</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Matrix</span><span class="params">(<span class="type">size_t</span> size)</span> : size_(size) &#123;</span></span><br><span class="line">    data = <span class="keyword">new</span> <span class="type">double</span>[size * size]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.明确调用意图</span></span><br><span class="line"><span class="comment">// compute(1000);           // ❌ 编译错误</span></span><br><span class="line"><span class="built_in">compute</span>(<span class="built_in">Matrix</span>(<span class="number">4</span>));   <span class="comment">// ✅ 明确知道在创建矩阵</span></span><br></pre></td></tr></table></figure>

<p>这种场景，主要防止的是，有可能开发人员根本没有意识到会触发内存分配，或者误在性能敏感的代码中意外创建大对象。<br>当然，如果的确需要创建，就显式构造，开发知道自己在干什么，可以对自己的行为负责。</p>
<h2 id="加上explicit对列表初始化的影响"><a href="#加上explicit对列表初始化的影响" class="headerlink" title="加上explicit对列表初始化的影响"></a>加上explicit对列表初始化的影响</h2><p>分析完单参数构造函数非必要最好加上<code>explicit</code>关键字之后，我们再看看，如果多参数构造函数加上<code>explicit</code>，又会有什么影响呢？</p>
<p>官方的说法是：当<code>explicit</code>构造函数接受<code>std::initializer_list</code>时，会失去所有数量的初值的隐式转换能力。<br>（说起来有点绕口，直接看例子就清晰了。）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 非explicit版本</span></span><br><span class="line">    <span class="built_in">Container</span>(std::initializer_list&lt;<span class="type">int</span>&gt; values);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SafeContainer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// explicit版本</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SafeContainer</span><span class="params">(std::initializer_list&lt;<span class="type">int</span>&gt; values)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对比效果</span></span><br><span class="line">Container c1 = &#123;&#125;;           <span class="comment">// ✅ 0个初值 隐式转换</span></span><br><span class="line">Container c2 = &#123;<span class="number">42</span>&#125;;         <span class="comment">// ✅ 1个初值 隐式转换</span></span><br><span class="line">Container c3 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;    <span class="comment">// ✅ 多个初值 隐式转换</span></span><br><span class="line"></span><br><span class="line">SafeContainer sc1 = &#123;&#125;;      <span class="comment">// ❌ 失去0个初值的隐式转换</span></span><br><span class="line">SafeContainer sc2 = &#123;<span class="number">42</span>&#125;;    <span class="comment">// ❌ 失去1个初值的隐式转换</span></span><br><span class="line">SafeContainer sc3 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// ❌ 失去多个初值的隐式转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须使用直接初始化</span></span><br><span class="line">SafeContainer sc4&#123;&#125;;         <span class="comment">// ✅ 0个初值</span></span><br><span class="line">SafeContainer sc5&#123;<span class="number">42</span>&#125;;       <span class="comment">// ✅ 1个初值</span></span><br><span class="line">SafeContainer sc6&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  <span class="comment">// ✅ 多个初值</span></span><br></pre></td></tr></table></figure>

<h2 id="加上explicit对多参数构造函数的影响"><a href="#加上explicit对多参数构造函数的影响" class="headerlink" title="加上explicit对多参数构造函数的影响"></a>加上explicit对多参数构造函数的影响</h2><p>如果是普通的多参数构造函数加上<code>explicit</code>，又会有什么影响呢？<br>先说答案：直接初始化仍然不受影响，但拷贝初始化会受到影响。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">P</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">P</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">P obj1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;        <span class="comment">// ✅ 直接初始化，总是可以</span></span><br><span class="line"><span class="function">P <span class="title">obj2</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;        <span class="comment">// ✅ 直接初始化，总是可以</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">P obj3 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;     <span class="comment">// ❌ 拷贝初始化，explicit会阻止</span></span><br><span class="line">P obj4 = P&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;    <span class="comment">// ✅ 显式构造后拷贝，可以</span></span><br></pre></td></tr></table></figure>

<p>为什么加<code>explicit</code>会影响拷贝初始化呢？<br>分析下来是因为拷贝初始化需要两步：</p>
<ol>
<li>用<code>&#123;1, 2, 3&#125;</code>创建临时对象（需要隐式调用构造函数）</li>
<li>将临时对象拷贝给目标变量<br>而<code>explicit</code>阻止了第一步的隐式调用。</li>
</ol>
<hr>
<p>有些场景需要加，但是有些场景我们又不应该使用explicit</p>
<h2 id="拷贝和移动构造函数绝对不要加explicit"><a href="#拷贝和移动构造函数绝对不要加explicit" class="headerlink" title="拷贝和移动构造函数绝对不要加explicit"></a>拷贝和移动构造函数绝对不要加<code>explicit</code></h2><p>虽然 C++ 语法上允许你给拷贝&#x2F;移动构造函数加上 explicit，但在工程实践中，这样做基本等于“自杀”，或者说是给使用者（包括你自己）制造巨大的麻烦。</p>
<p>如果说拷贝和移动构造函数加了<code>explicit</code>，这会发生什么？<br>答案是：会破坏基本语义，破坏函数传递，破坏容器使用，破坏返回值语义。<br>品一品，是不是这么回事。<br>上代码细看。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 永远不要这样做</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">const</span> MyClass&amp; other)</span></span>;  <span class="comment">// ❌</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(MyClass&amp;&amp; other)</span></span>;       <span class="comment">// ❌</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.破坏基本语义</span></span><br><span class="line">MyClass obj1;</span><br><span class="line"><span class="function">MyClass <span class="title">obj2</span><span class="params">(obj1)</span></span>; <span class="comment">// ✅ 允许：直接调用（像函数调用一样）</span></span><br><span class="line">MyClass obj3 = obj1;  <span class="comment">// ❌ 如果拷贝构造是explicit，这会编译错误！因为等号 &quot;=&quot; 语义上要求隐式转换。</span></span><br><span class="line">                      <span class="comment">// 这意味着你无法再使用最自然的 = 进行赋值初始化了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.破坏函数传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(MyClass obj)</span></span>;  <span class="comment">// 按值传递</span></span><br><span class="line">MyClass original;</span><br><span class="line"><span class="built_in">process</span>(original);  <span class="comment">// ❌ 如果拷贝构造是explicit，无法传递参数！这是因为为了把 original 传进函数，需要构造一个临时对象。这是一次隐式动作，被 explicit 拦截了。</span></span><br><span class="line"><span class="comment">// 你被迫要写成这样这种恶心的代码：</span></span><br><span class="line"><span class="built_in">process</span>(<span class="built_in">MyClass</span>(original)); <span class="comment">// ✅ 显式强转</span></span><br><span class="line">                        <span class="comment">// 如果所有的类都这样写，C++ 的函数调用简直没法看了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.破坏容器使用</span></span><br><span class="line">std::vector&lt;MyClass&gt; vec;</span><br><span class="line">MyClass obj;</span><br><span class="line">vec.<span class="built_in">push_back</span>(obj);  <span class="comment">// ❌ 容器无法工作！</span></span><br><span class="line"><span class="comment">// 标准库容器依赖于拷贝/移动语义 </span></span><br><span class="line"><span class="comment">// 很多 STL 操作内部逻辑是：在内存中放置新对象时，使用了 = 语义或者隐式构造语义。</span></span><br><span class="line"><span class="comment">// 如果拷贝/移动构造函数是 explicit 的，你的类基本上就告别 STL 标准库了，除非你用非常小心翼翼的 emplace 操作，但也很容易踩雷。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.破坏返回值语义</span></span><br><span class="line"><span class="function">MyClass <span class="title">createObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="keyword">return</span> obj;  <span class="comment">// ❌ 无法返回对象！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在语义检查阶段，return 语句被视为一种“隐式构造”</span></span><br></pre></td></tr></table></figure>


<p>关于拷贝&#x2F;移动构造函数加<code>explicit</code>会破坏返回值语义，有些小伙伴可能像我一样，在这里会有一个疑问：“C++ 不是有 RVO&#x2F;NRVO (返回值优化) 吗？编译器不是会把拷贝直接消除掉吗？既然消除了，为什么还要检查构造函数？”</p>
<p>这是因为这里有两步：</p>
<p>语义检查 (Semantic Check)：编译器的第一步是检查“如果你要拷贝，代码写得对不对”。这一步要求拷贝&#x2F;移动构造函数必须是可访问的且非 explicit 的。</p>
<p>代码生成与优化 (Code Generation &amp; Optimization)：只有通过了语义检查，编译器才会进行第二步优化（RVO），在运行时消除这次拷贝。</p>
<p>所以，结论就是：即使 RVO 会在运行时消除拷贝，<code>explicit</code> 依然会在编译时导致报错，因为它阻断了语义检查阶段的合法性。</p>
<hr>
<p>正确的做法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ✅ 正常的拷贝和移动构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 或者如果不需要拷贝，就删除它们</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>explicit</code> 的核心目的是防止意外的类型转换（比如把 int 变成 String）。</p>
<p>但是，拷贝和移动本身就是同一种类型的传递，它们在 C++ 语言层面被设计为一种“自然流动”的操作。阻断这种流动（加上 explicit），就会导致这个类在 C++ 的生态系统中寸步难行。</p>
<p>参考 Google C++ 编程规范的建议,我的使用原则目前是：</p>
<p>（1）原则上，所有的单参数构造函数都应该加上 <code>explicit</code>。<br>  <em>除非你真的希望用户使用这种隐式转换带来便利。（例如模拟基础数据类型）</em></p>
<p>（2）多参数构造函数（C++11 之前通常不需要，但 C++11 引入了列表初始化 {}）按具体场景决定加不加<code>explicit</code>：<br>  <em>如果构造函数支持列表初始化，且你不想让 {1, 2} 隐式变成你的对象，也要加 explicit。</em></p>
<p>（3）拷贝&#x2F;移动构造函数，绝对不要加 <code>explicit</code>。</p>
<p>(大家有什么使用习惯吗？欢迎评论区交流)</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 单元测试黑魔法：`#define private public`</title>
    <url>/posts/be9c26b5.html</url>
    <content><![CDATA[<p>在 C++ 单元测试的世界里，一直流传着一个“邪道”技巧。</p>
<p>当你面对一个庞大的遗留类，想要测试其中一个复杂的 <code>private</code> 辅助函数，或者验证某个 <code>private</code> 成员变量的状态，但又不想（或不能）修改原始头文件去添加 <code>friend</code> 声明时，很多人的第一反应是使用那个著名的“黑魔法”：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> private public</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> protected public</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyLegacyClass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> private</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> protected</span></span><br></pre></td></tr></table></figure>

<h2 id="一、-黑魔法的原理：欺骗编译器"><a href="#一、-黑魔法的原理：欺骗编译器" class="headerlink" title="一、 黑魔法的原理：欺骗编译器"></a>一、 黑魔法的原理：欺骗编译器</h2><p>这个技巧的核心逻辑非常简单粗暴：<strong>预处理器的宏替换</strong>。</p>
<p>C++ 的编译过程是分阶段的。在编译器真正开始语法分析之前，预处理器会先处理所有的 <code>#include</code> 和 <code>#define</code>。</p>
<p>当我们写下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> private public</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyLegacyClass.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>预处理器在展开 <code>MyLegacyClass.h</code> 时，会将其中的所有 <code>private</code> 关键字替换为 <code>public</code>。<br>对于编译器来说，在编译 <code>Test.cpp</code> 这个单元时，<code>MyLegacyClass</code> 的所有成员<strong>确实就是公有的</strong>。因此，测试代码可以直接调用 <code>MyLegacyClass::PrivateFunc()</code> 而不会报“访问权限错误”。</p>
<p>这是编译期的欺骗，很完美，对吧？</p>
<h2 id="二、-在-Linux-GCC-Clang-上屡试不爽"><a href="#二、-在-Linux-GCC-Clang-上屡试不爽" class="headerlink" title="二、 在 Linux (GCC&#x2F;Clang) 上屡试不爽"></a>二、 在 Linux (GCC&#x2F;Clang) 上屡试不爽</h2><p>在 Linux 环境下，GCC 和 Clang 遵循 <strong>Itanium C++ ABI</strong>（应用程序二进制接口）标准。</p>
<p>在该标准下，函数的<strong>符号修饰（Name Mangling）</strong>主要包含函数名、命名空间和参数类型等信息，但通常<strong>不包含访问控制级别（public&#x2F;private&#x2F;protected）</strong>。</p>
<p>也就是说，对于下面这个函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLegacyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrivateFunc</span><span class="params">(<span class="type">int</span> type)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>无论它是 <code>private</code> 还是 <code>public</code>，GCC 生成的符号名可能都是类似 <code>_ZN7Scanner11UpdateTokenEi</code> 的样子。</p>
<ol>
<li><strong>库的编译</strong>：<code>MyLegacyClass.cpp</code> 正常编译，<code>PrivateFunc</code> 是 private，生成符号 <code>_ZN7Scanner11UpdateTokenEi</code>。</li>
<li><strong>测试的编译</strong>：<code>Test.cpp</code> 用了黑魔法，编译器以为 <code>PrivateFunc</code> 是 public，生成调用指令，寻找符号 <code>_ZN7Scanner11UpdateTokenEi</code>。</li>
<li><strong>链接</strong>：链接器发现两个符号名字一样，<strong>链接成功</strong>！</li>
</ol>
<p>在实践中，Itanium ABI 往往能“宽容”地让它跑通。因此，这一招在 Linux 环境下（使用 GCC 或 Clang）屡试不爽，属于“快速通关”的秘籍。</p>
<p>不过，需要注意的是，当你试图将代码移植到 Windows 环境，使用 Visual Studio (MSVC) 编译时，黑魔法就会失效——**链接错误 (LNK2019)**。</p>
<hr>
<h2 id="三、-Windows-MSVC-的滑铁卢：LNK2019"><a href="#三、-Windows-MSVC-的滑铁卢：LNK2019" class="headerlink" title="三、 Windows (MSVC) 的滑铁卢：LNK2019"></a>三、 Windows (MSVC) 的滑铁卢：LNK2019</h2><p>如果在 Windows 上使用 MSVC 编译器做同样的事情，你会收到类似这样的错误：</p>
<blockquote>
<p><strong>error LNK2019</strong>: 无法解析的外部符号  “public: bool __cdecl MyLegacyClass::PrivateFunc(int)” (?PrivateFunc@MyLegacyClass@@QEAAXH@Z)，函数 “private: virtual void __cdecl ATest_APrivateFuncCase_Test::TestBody(void)”(?TestBody@ATest_APrivateFuncCase_Test@@EEAAXXZ) 中引用了该符号</p>
</blockquote>
<p>这表明你使用 <code>#define private public</code> 这种“黑魔法”虽然欺骗了编译器（Compiler），让你在测试代码中可以调用私有函数，但它改变不了链接器（Linker）的事实。</p>
<h3 id="根本原因：MSVC-的符号修饰包含访问级别"><a href="#根本原因：MSVC-的符号修饰包含访问级别" class="headerlink" title="根本原因：MSVC 的符号修饰包含访问级别"></a>根本原因：MSVC 的符号修饰包含访问级别</h3><p>微软的 C++ ABI 与 Itanium ABI 不同。MSVC 在生成函数的修饰名（Mangled Name）时，<strong>将函数的访问控制权限（Access Specifier）编码进了符号名里</strong>。</p>
<p>我们来看一下区别：</p>
<table>
<thead>
<tr>
<th align="left">代码定义</th>
<th align="left">访问权限</th>
<th align="left">MSVC 生成的符号名 (大致示意)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>void PrivateFunc(int)</code></td>
<td align="left"><strong>private</strong></td>
<td align="left"><code>?PrivateFunc@MyLegacyClass@@AEAAXH@Z</code></td>
</tr>
<tr>
<td align="left"><code>void PrivateFunc(int)</code></td>
<td align="left"><strong>public</strong></td>
<td align="left"><code>?PrivateFunc@MyLegacyClass@@QEAAXH@Z</code></td>
</tr>
</tbody></table>
<p>我们注意到:</p>
<ul>
<li>Private 版本包含 <strong><code>A</code></strong> (<code>AEAA...</code>)</li>
<li>Public 版本包含 <strong><code>Q</code></strong> (<code>QEAA...</code>)</li>
</ul>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li><p>**源文件编译 (<code>MyLegacyClass.cpp</code>)**：<br>你编译项目源代码时，没有加黑魔法。编译器看到的是 <code>private</code>，生成的 <code>MyLegacyClass.obj</code> 里，函数的符号是 **带 A 的 (Private 版)**。</p>
</li>
<li><p><strong>测试文件编译 (<code>Test.cpp</code>)<strong>：<br>你使用了 <code>#define private public</code>。编译器被欺骗了，它认为 <code>PrivateFunc</code> 是 <code>public</code> 的。于是它在生成 <code>Test.obj</code> 时，生成了一个</strong>寻找 带 Q 的 (Public 版)</strong> 符号的指令。</p>
</li>
<li><p><strong>链接阶段</strong>：<br>链接器开始工作。测试代码大喊：“给我一个 <code>...QEAA...</code> (Public) 的函数！”<br>由于只有 <code>MyLegacyClass.obj</code>，它回答：“我只有 <code>...AEAA...</code> (Private) 的版本。”<br><strong>链接器：不匹配，报错，LNK2019。</strong></p>
</li>
</ol>
<p>这就是为什么<code>MSVC</code>下加了黑魔法，却仍然死活链接不上的原因。</p>
<h2 id="四、-更推荐的解决方案"><a href="#四、-更推荐的解决方案" class="headerlink" title="四、 更推荐的解决方案"></a>四、 更推荐的解决方案</h2><p>一般来说，我们 <code>#define private public</code> 是未定义行为且在 Windows 上不可用，我们应该如何测试私有成员呢？</p>
<h3 id="1-使用-Google-Test-的-FRIEND-TEST-推荐"><a href="#1-使用-Google-Test-的-FRIEND-TEST-推荐" class="headerlink" title="1. 使用 Google Test 的 FRIEND_TEST (推荐)"></a>1. 使用 Google Test 的 <code>FRIEND_TEST</code> (推荐)</h3><p>这是最标准、最安全的方法。它利用了 C++ 的 <code>friend</code> 机制，专门为测试开放白名单。</p>
<p><strong>在头文件中：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest_prod.h&gt;</span> <span class="comment">// 引入 gtest 里的这个头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLegacyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrivateFunc</span><span class="params">(<span class="type">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许 ATest 类的 APrivateFuncCase 测试用例访问私有成员</span></span><br><span class="line">    <span class="built_in">FRIEND_TEST</span>(ATest, APrivateFuncCase);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>在测试文件中：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(ATest, APrivateFuncCase) &#123;</span><br><span class="line">    MyLegacyClass scan;</span><br><span class="line">    <span class="comment">// 直接访问，合法的！</span></span><br><span class="line">    scan.<span class="built_in">PrivateFunc</span>(<span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式生成的符号名是完全一致的，无论在 Linux 还是 Windows 都能完美运行。</p>
<h3 id="2-也是一种思路：Pimpl-模式"><a href="#2-也是一种思路：Pimpl-模式" class="headerlink" title="2. 也是一种思路：Pimpl 模式"></a>2. 也是一种思路：Pimpl 模式</h3><p>如果你的私有逻辑非常复杂以至于需要大量测试，这通常意味着该逻辑应该被提取到一个独立的类中（Impl 类）。你可以将这个 Impl 类设为 public（或在内部头文件中定义），然后单独对其进行测试。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>#define private public</code> 就像是程序员的禁术。它在 Linux&#x2F;GCC 的宽容下或许能让你尝到甜头，但在 Windows&#x2F;MSVC 严谨的 ABI 规则面前，它会罢工报警。<br>还是权衡一下使用场景再决定要不要用吧。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>单元测试</tag>
        <tag>google test</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 会话 ID (Session ID) 与 Session 0 隔离穿透指南</title>
    <url>/posts/f5974992.html</url>
    <content><![CDATA[<h2 id="1-背景：开机自启动程序无法弹出界面？"><a href="#1-背景：开机自启动程序无法弹出界面？" class="headerlink" title="1. 背景：开机自启动程序无法弹出界面？"></a>1. 背景：开机自启动程序无法弹出界面？</h2><p>在开发 Windows 后台服务（Service）或开机自启程序时，经常遇到一个棘手的问题：</p>
<p><strong>场景描述：</strong><br>有一个 GUI 程序 <code>getCode.exe</code> 需要开机自启动并与用户交互（例如弹出窗口让用户输入）。</p>
<ul>
<li><strong>尝试 1</strong>：最初直接使用 <code>nssm</code> 将 <code>getCode.exe</code> 注册为 Windows 服务。<ul>
<li><strong>结果</strong>：程序启动了，但在后台默默运行，用户界面完全看不到，对键盘鼠标无反应。</li>
</ul>
</li>
<li><strong>尝试 2</strong>：开机后手动双击运行 <code>getCode.exe</code>。<ul>
<li><strong>结果</strong>：程序正常显示，交互正常。</li>
</ul>
</li>
</ul>
<p><strong>原因分析：</strong><br>通过上网翻找资料，查看任务管理器后发现：</p>
<ul>
<li>通过 <code>nssm</code> 启动的进程，其 <strong>会话 ID (Session ID)</strong> 为 <code>0</code>。</li>
<li>用户手动启动的进程，其 <strong>会话 ID</strong> 为 <code>1</code>（或更高）。</li>
<li>当前登录用户正在操作的桌面属于 Session 1，而 Session 0 的程序无法直接在 Session 1 的桌面上显示界面。</li>
</ul>
<p>原来这就是 Windows 的 <strong>Session 0 隔离机制</strong> ——服务运行在 Session 0，而用户交互桌面在 Session 1&#x2F;2&#x2F;…；Session 0 中创建的界面用户看不见，也无法接收用户输入。</p>
<p><strong>解决方案思路：</strong><br>考虑了项目的使用场景，最后决定编写一个“启动器”服务（例如 <code>setExeSID.exe</code>），它的职责不是自己显示界面，而是探测当前用户所在的 Session ID，然后使用 Windows API “穿透”隔离，将目标程序 <code>getCode.exe</code> 注入到用户的 Session 中运行。</p>
<p><strong>大概逻辑为：</strong></p>
<ol>
<li><code>setExeSID.exe</code> 由 nssm 注册为服务，开机自启（因此它在 <strong>Session 0</strong>）。</li>
<li><code>setExeSID.exe</code> 获取当前活动用户的 Session ID（通常是 <strong>1</strong>，也可能是 2&#x2F;3…）。</li>
<li><code>setExeSID.exe</code> 以该 Session 的用户 Token 为上下文，调用 <code>CreateProcessAsUser</code> 在用户会话中启动 <code>getCode.exe</code>（运行在用户桌面 <code>winsta0\default</code>）。</li>
</ol>
<p><strong>预期效果</strong>：<br>仍然实现开机自启动（靠服务）<br><code>getCode.exe</code> 实际运行在当前登录用户的 Session 中，可以正常显示 UI 并交互</p>
<hr>
<h2 id="2-查看会话ID"><a href="#2-查看会话ID" class="headerlink" title="2. 查看会话ID"></a>2. 查看会话ID</h2><p>打开“任务管理器” -&gt; “详细信息”选项卡 -&gt; 右键表头“选择列” -&gt; 勾选“会话 ID”。</p>
<p><img src="/images/look_sid.jpg" alt="look_sid.jpg"></p>
<hr>
<h2 id="3-Session-0-隔离（为什么服务无法交互）"><a href="#3-Session-0-隔离（为什么服务无法交互）" class="headerlink" title="3. Session 0 隔离（为什么服务无法交互）"></a>3. Session 0 隔离（为什么服务无法交互）</h2><h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><ul>
<li><strong>Windows XP 时代</strong>：系统服务和第一个登录的用户都运行在 Session 0。服务可以直接弹出窗口（<code>MessageBox</code>），用户能看到并交互。这带来了巨大的安全风险（例如 Shatter Attack，恶意程序向服务窗口发送消息提升权限）。</li>
<li><strong>Windows Vista &#x2F; 7 &#x2F; 10 &#x2F; 11</strong>：引入了 <strong>Session 0 隔离</strong>。<ul>
<li><strong>Session 0</strong>：<strong>专用于系统服务</strong>。非交互式，没有用户界面。</li>
<li><strong>Session 1, 2…<strong>：</strong>用户会话</strong>。第一个登录的用户分配 Session 1，远程桌面用户分配 Session 2 等。</li>
</ul>
</li>
</ul>
<h3 id="为什么普通启动会失败？"><a href="#为什么普通启动会失败？" class="headerlink" title="为什么普通启动会失败？"></a>为什么普通启动会失败？</h3><p>当服务（Session 0）尝试启动一个带 UI 的进程时，该进程默认继承父进程的 Session ID (0)。由于 Session 0 无法访问用户的显卡驱动和桌面环境（<code>winsta0\default</code>），UI 渲染会失败，或者被系统拦截在不可见的后台。</p>
<hr>
<h2 id="4-核心做法：如何穿透？"><a href="#4-核心做法：如何穿透？" class="headerlink" title="4. 核心做法：如何穿透？"></a>4. 核心做法：如何穿透？</h2><p>要实现从 Session 0 启动进程到 Session 1，不能使用简单的 <code>CreateProcess</code> 或 <code>system()</code>，必须使用 <strong>Windows API</strong> 进行令牌（Token）操作。</p>
<h3 id="关键步骤流程"><a href="#关键步骤流程" class="headerlink" title="关键步骤流程"></a>关键步骤流程</h3><ol>
<li><strong>定位目标</strong>：找到当前正在活动的（用户正在看的）Session ID (<code>WTSGetActiveConsoleSessionId</code>)。</li>
<li><strong>获取令牌</strong>：拿到该 Session 中用户的身份令牌 (<code>WTSQueryUserToken</code>)。</li>
<li><strong>复制令牌</strong>：将令牌复制一份，并转换为主令牌 (<code>DuplicateTokenEx</code>)。</li>
<li><strong>处理环境</strong>：为新进程创建正确的环境变量块 (<code>CreateEnvironmentBlock</code>)，否则程序可能找不到路径。</li>
<li><strong>跨界启动</strong>：使用 <strong><code>CreateProcessAsUser</code></strong> 启动进程，并显式指定运行在交互式桌面 (<code>winsta0\default</code>)。</li>
</ol>
<h3 id="涉及到的主要-API"><a href="#涉及到的主要-API" class="headerlink" title="涉及到的主要 API"></a>涉及到的主要 API</h3><p>涉及到的主要 API 及其作用</p>
<ul>
<li><p><code>GetCurrentProcess</code><br>获取当前进程伪句柄（常用于配合 <code>OpenProcessToken</code>）。</p>
</li>
<li><p><code>OpenProcessToken</code><br>打开进程访问令牌（Token），用于查询&#x2F;调整权限。</p>
</li>
<li><p><code>LookupPrivilegeValue</code> + <code>AdjustTokenPrivileges</code><br>为当前进程启用某些特权。<br>常见原因：<code>CreateProcessAsUser</code> &#x2F; 资源配额调整等需要特权。<br>注意：<strong>前提是账户本身拥有该特权</strong>，只是默认未启用。</p>
</li>
<li><p>（会话枚举&#x2F;定位）</p>
<ul>
<li><code>WTSEnumerateSessions</code>：枚举会话列表（可选）</li>
<li><code>WTSGetActiveConsoleSessionId</code>：获取当前物理控制台活动会话（常用）</li>
<li><code>WTSQueryUserToken</code>：获取指定 Session 的用户 Token（常用）</li>
</ul>
</li>
<li><p><code>DuplicateTokenEx</code><br>将 Token 复制为可用于创建进程的 <strong>Primary Token</strong>（常见必做步骤）。</p>
</li>
<li><p><code>CreateEnvironmentBlock</code><br>为目标用户创建环境变量块（否则新进程可能继承服务的环境，导致路径&#x2F;变量异常）。</p>
</li>
<li><p><code>CreateProcessAsUser</code><br>以指定用户的安全上下文创建进程。<br>关键点：默认新进程可能是非交互桌面，需要在 <code>STARTUPINFO.lpDesktop</code> 指定交互桌面。<br><code>STARTUPINFO.lpDesktop = L&quot;winsta0\\default&quot;</code><br>否则可能创建在不可见桌面，表现为“进程在跑但看不见&#x2F;不能交互”。</p>
</li>
</ul>
<h2 id="5-常见坑与注意事项"><a href="#5-常见坑与注意事项" class="headerlink" title="5. 常见坑与注意事项"></a>5. 常见坑与注意事项</h2><ol>
<li><p><strong>服务权限问题</strong>：<br>你的“启动器服务”必须以 <strong>LocalSystem (本地系统)</strong> 账户运行。如果以 <code>LocalService</code> 或 <code>NetworkService</code> 运行，调用 <code>WTSQueryUserToken</code> 会直接返回 <code>ERROR_PRIVILEGE_NOT_HELD</code> (错误码 1314)。</p>
</li>
<li><p><strong>无人登录时的情况</strong>：<br>如果电脑刚开机，停留在登录界面（LogonUI），此时 <code>WTSGetActiveConsoleSessionId</code> 可能返回 Session 1，但并没有即时用户。如果在此时启动程序，程序会在登录界面后台运行，用户输入密码进入桌面后可能反而看不到了。<br>最好在服务中做一个轮询，检测到有真实用户登录（Session ID &gt; 0 且状态为 Active）后再启动。</p>
</li>
<li><p><strong>用户文件访问权限</strong>：<br>虽然进程在用户 Session 中运行，但如果涉及到读写特定的网络共享路径或加密文件夹，仍需注意令牌的权限范围。</p>
</li>
</ol>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>当 Windows 上的程序需要：</p>
<ul>
<li><strong>开机自启动</strong>（常由服务实现）</li>
<li>同时又需要<strong>用户交互（UI&#x2F;输入）</strong></li>
</ul>
<p>就必须考虑 <strong>Session 0 隔离</strong>。服务所在的 Session 0 与用户交互会话隔离，直接启动的 UI 程序往往不可交互。常见做法是：服务在 Session 0 中运行，引导在当前用户 Session 中创建进程（<code>WTSQueryUserToken</code> + <code>CreateProcessAsUser</code>），或采用服务与用户端代理的架构通过 IPC 完成交互。</p>
<p>这样就可以完美实现开机自启服务与用户桌面的无缝交互。（比如开发远程协助软件）</p>
<h2 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h2><p><a href="https://cloud.tencent.com/developer/article/1424933">关于突破SESSION 0隔离创建进程</a></p>
<p><a href="https://blog.csdn.net/yockie/article/details/17029293">总结了用户权限设置和进程权限提升，提权demo也可参考</a></p>
<p><a href="http://yfvb.com/help/win32sdk/index.htm?page=html/_qx5ll.htm">总结了window API</a></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>windows</tag>
        <tag>Session ID</tag>
      </tags>
  </entry>
  <entry>
    <title>centos或mac下使用locate指令时，报错</title>
    <url>/posts/988cb25a.html</url>
    <content><![CDATA[<h1 id="centos或mac下使用locate指令时，报错-var-db-locate-database"><a href="#centos或mac下使用locate指令时，报错-var-db-locate-database" class="headerlink" title="centos或mac下使用locate指令时，报错(&#x2F;var&#x2F;db&#x2F;locate.database)"></a>centos或mac下使用locate指令时，报错(&#x2F;var&#x2F;db&#x2F;locate.database)</h1><p>centos或mac下使用locate指令时，出现报错信息The locate database (&#x2F;var&#x2F;db&#x2F;locate.database)</p>
<h2 id="在centos系统下，使用locate指令报错"><a href="#在centos系统下，使用locate指令报错" class="headerlink" title="在centos系统下，使用locate指令报错"></a>在centos系统下，使用locate指令报错</h2><p>使用locate指令时，出现报错信息’var&#x2F;lib&#x2F;mlocate&#x2F;mlocate.db’:No such file or directory时，处理方案如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入以下指令即可</span></span><br><span class="line">updatedb</span><br><span class="line"><span class="comment">//需要等待一段时间，因为生成数据库需要一段时间</span></span><br></pre></td></tr></table></figure>

<p>稍等一段时间之后，再输入locate指令，即可发现可以使用了</p>
<h2 id="在mac系统下，使用locate指令报错"><a href="#在mac系统下，使用locate指令报错" class="headerlink" title="在mac系统下，使用locate指令报错"></a>在mac系统下，使用locate指令报错</h2><p>当在mac上使用locate指令时，报错如下：<br><img src="/images/locate_01.jpg" alt="使用locate指令时报错"></p>
<p>解决方案如下：</p>
<ol>
<li><p>先根据刚才的提醒，输入sudo launchctl load -w &#x2F;System&#x2F;Library&#x2F;LaunchDaemons&#x2F;com.apple.locate.plist<br><img src="/images/locate_02.jpg" alt="根据提示，输入launchtcl指令"></p>
</li>
<li><p>然后，输入指令sudo &#x2F;usr&#x2F;libexec&#x2F;locate.updatedb<br><img src="/images/locate_03.jpg" alt="生成数据库"></p>
</li>
</ol>
<p>输入上面这个指令后，会等待好久一段时间，要稍微等待一会儿</p>
<ol start="3">
<li>最后再次输入locate指令，发现locate指令已经生效啦<br><img src="/images/locate_04.jpg" alt="locate指令已经生效啦"></li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>因为我之前经常在ubuntu下，都没有碰到过locate指令不好用的情况，最近需要在centos和mac下操作，忽然发现居然loacte指令使用失效，于是上网查找了解决办法，经过尝试了一些方案后，终于在centos和mac下可以使用locate指令了，因此做出了以上的总结～</p>
<p>感谢网友们无私分享的解决方案～<br>参考的网友方案：<a href="https://www.jianshu.com/p/d8f4f9e4b58c">https://www.jianshu.com/p/d8f4f9e4b58c</a></p>
]]></content>
      <categories>
        <category>技术折腾</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>cjson库版本不一致，导致解析失败</title>
    <url>/posts/ae350693.html</url>
    <content><![CDATA[<h1 id="cjson库版本不一致，导致解析失败"><a href="#cjson库版本不一致，导致解析失败" class="headerlink" title="cjson库版本不一致，导致解析失败"></a>cjson库版本不一致，导致解析失败</h1><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>在编译一个程序demo的时候，需要继承一个第三方库libexample.so，第三方库用到了cjson，本身这个程序也用到了cjson，由于两者用的cjson的版本不一致，导致json解析失败……</p>
<h2 id="旧版本cjson"><a href="#旧版本cjson" class="headerlink" title="旧版本cjson"></a>旧版本cjson</h2><p>第三方库libexample.so使用的旧版本的cjson，cjson-types截图如下：<br><img src="/images/cjson_old_version.jpg" alt="cjson_old_version.jpg"></p>
<h2 id="新版本cjson"><a href="#新版本cjson" class="headerlink" title="新版本cjson"></a>新版本cjson</h2><p>程序demo使用的是新版本的cjson，cjson-types截图如下：<br><img src="/images/cjson_new_version.jpg" alt="cjson_new_version.jpg"></p>
<h2 id="具体现象"><a href="#具体现象" class="headerlink" title="具体现象"></a>具体现象</h2><p>用旧版本的cJSON源码编译到自己的代码里，编译出libexample.so库；<br>程序demo已经使用过新版本的cJSON源码，但是又连接了上面编译出来的libexample.so的库，再次进行json解析，会发现libexample.so里面解析cJSON_Number类型的节点的值会失败；<br>然后重新用新版本的cJSON源码编译出libexample.so库，再集成到上面的demo里面，即可解析成功。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>可以从上面两个不同版本的cjson源码截图的cjosn-types看出来：<br>这两个版本的cJSON Types的值不一样，比如cJSON_Number类型节点的值，旧版本的值是3， 新版本的值是8，<br>所以用旧版本编译的libexample.so库，集成到demo里的时候，解析到cJSON_Number节点的时候，错误的使用值8而不是3，所以导致解析失败</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>代码里一定要保持一个版本的cjson；<br>版本混乱很容易造成奇怪的问题，而且这种问题往往还不容易排查！</p>
]]></content>
      <categories>
        <category>技术折腾</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>cjson</tag>
      </tags>
  </entry>
  <entry>
    <title>如何通过CMake修改 Windows 程序的主线程栈大小</title>
    <url>/posts/b2c5f831.html</url>
    <content><![CDATA[<h1 id="CMake选项之CMAKE-EXE-LINKER-FLAGS"><a href="#CMake选项之CMAKE-EXE-LINKER-FLAGS" class="headerlink" title="CMake选项之CMAKE_EXE_LINKER_FLAGS"></a>CMake选项之CMAKE_EXE_LINKER_FLAGS</h1><h1 id="如何通过CMake修改-Windows-程序的主线程栈大小"><a href="#如何通过CMake修改-Windows-程序的主线程栈大小" class="headerlink" title="如何通过CMake修改 Windows 程序的主线程栈大小"></a>如何通过CMake修改 Windows 程序的主线程栈大小</h1><p>只需要在CMakeLists.txt里添加如下一行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="string">&quot;<span class="variable">$&#123;CMAKE_EXE_LINKER_FLAGS&#125;</span> /STACK:10000000&quot;</span>) </span><br></pre></td></tr></table></figure>

<p>这个命令的作用是 <strong>修改 Windows 程序的主线程栈大小（Stack Size）</strong>。</p>
<p>具体来说：</p>
<ul>
<li>**<code>/STACK:10000000</code>**：这是传给 Windows 链接器（Linker）的一个参数。</li>
<li>**<code>10000000</code>**：单位是字节（Bytes）。<ul>
<li>$10,000,000 \text{ Bytes} \approx 9.5 \text{ MB}$。</li>
</ul>
</li>
</ul>
<h3 id="为什么要加这一行？"><a href="#为什么要加这一行？" class="headerlink" title="为什么要加这一行？"></a>为什么要加这一行？</h3><p>默认情况下，Windows 程序的栈大小通常只有 <strong>1MB</strong>。如果你的程序中存在以下情况，1MB 就不够用了，会导致 <strong>Stack Overflow（栈溢出）</strong> 崩溃：</p>
<ol>
<li><strong>超大的局部数组</strong>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这种大数组是分配在栈上的</span></span><br><span class="line">    <span class="comment">// 如果数组太大（比如 double arr[200000]），就会直接撑爆默认的 1MB 栈</span></span><br><span class="line">    <span class="type">double</span> hugeArray[<span class="number">500000</span>]; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>极深的递归调用</strong>：<br>比如解析复杂的 G 代码结构，或者某些算法（如快速排序的最坏情况、树的遍历）递归层数太深，每一层递归都会占用一点栈空间，累积起来就会溢出。</li>
<li><strong>复杂的类对象在栈上实例化</strong>：<br>如果你的某些类非常巨大（包含很多数据成员），并且你在函数里直接 <code>MyBigClass obj;</code> 这样定义，也会消耗大量栈空间。</li>
</ol>
<h3 id="这个修改意味着什么？"><a href="#这个修改意味着什么？" class="headerlink" title="这个修改意味着什么？"></a>这个修改意味着什么？</h3><p>你把栈空间从默认的 <strong>1MB</strong> 增加到了 <strong>约 10MB</strong>。</p>
<p>这是一种“暴力但有效”的手段，用来防止因栈空间不足导致的程序闪退。在仿真、图像处理软件中，一般会这样配。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>添加这行在CMake里就是在告诉编译器：<br><strong>“给我这个程序的主线程预留 10MB 的内存栈空间，我有些函数里局部变量很大，或者递归很深，默认的 1MB 不够用。”</strong></p>
]]></content>
      <categories>
        <category>技术折腾</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title>常用工具</title>
    <url>/posts/7050c2d4.html</url>
    <content><![CDATA[<h1 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h1><p>记录下常用的工具，持续更新</p>
<h2 id="visual-studio-code"><a href="#visual-studio-code" class="headerlink" title="visual studio code"></a>visual studio code</h2><p>生产力工具，不管是写markdown文档，渲染mermaid图，写代码等等，都很好用！</p>
<h3 id="配置C-git-中文相关插件"><a href="#配置C-git-中文相关插件" class="headerlink" title="配置C++,git,中文相关插件"></a>配置C++,git,中文相关插件</h3><p>git插件，c++插件都是装机必备，非常方便</p>
<p><img src="/images/vs_git.jpg" alt="vs_git.jpg"></p>
<h3 id="配置展示多行标签页"><a href="#配置展示多行标签页" class="headerlink" title="配置展示多行标签页"></a>配置展示多行标签页</h3><p>如果打开的标签页太多了，默认都是排一行，新的展示旧的被挤到后面去看不见了，这时选择多行展示标签页，会很方便</p>
<p>1.按住CTRL+SHIFT+P弹出搜索框，选中“首选项：打开工作区设置”</p>
<p><img src="/images/vs_set.jpg" alt="vs_set.jpg"></p>
<p>2.打开设置页面后，搜索“wrap”，选中“Wrap Tabs”就可以展示多行标签了</p>
<p><img src="/images/vs_wrap.jpg" alt="vs_wrap.jpg"></p>
<p>3.最后效果如下，框选出来的都是打开的标签页，可以展示多行了：</p>
<p><img src="/images/vs_show.jpg" alt="vs_show.jpg"></p>
<h2 id="PEView-ProcessExploer，vbox-valgrind，wireshark"><a href="#PEView-ProcessExploer，vbox-valgrind，wireshark" class="headerlink" title="PEView, ProcessExploer，vbox, valgrind，wireshark"></a>PEView, ProcessExploer，vbox, valgrind，wireshark</h2><p>这些找具体例子结合的时候再详说</p>
<h2 id="截图神器Snipaste"><a href="#截图神器Snipaste" class="headerlink" title="截图神器Snipaste"></a>截图神器Snipaste</h2><p>非常好用的截图神器，直接从官网下载了解压即可使用<br>常用功能<br>1.当Snipaste启动时，按下F1即可对屏幕进行截图<br>可以在截图时用“W、A、S、D”和键盘方向键分别对鼠标和截屏区域进行像素级移动</p>
<p>2.标注功能也很强大</p>
<p>3.按下F3可以贴图</p>
<h2 id="画图-一个被低估的神器"><a href="#画图-一个被低估的神器" class="headerlink" title="画图-一个被低估的神器"></a>画图-一个被低估的神器</h2><p>电脑自带的软件-画图 是一个被低估的神器<br>尤其是在做UI界面相关非常精细的工作的时候，如果需要1px的精度，那么就可以借助画图软件，<br>勾选“标尺”或“网格线”进行图片的放大缩小对比，可以非常好的看出来设计图和实现的图的效果对比<br>做很精细的UI的时候是一个非常好用的工具<br><img src="/images/paint.jpg" alt="paint.jpg"></p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么谷歌搜不到我的个人博客？（附 Hexo + GSC 完整收录指南）</title>
    <url>/posts/47478614.html</url>
    <content><![CDATA[<p>刚搭好 Hexo 博客，兴冲冲地在 Google 搜索栏输入 <code>site:catistrue.com</code>，结果却是“找不到任何与此相关的内容或信息”。</p>
<p><img src="/images/gsc/image.png" alt="找不到"></p>
<p>那种心情，大概就像是新开了一家店，装修得漂漂亮亮，结果门口连个路牌都没有，谁也找不到。</p>
<p>今天记录一下我为了让 Google 收录我的博客，踩过的坑和最终的解决方案。<br>如果你也像我之前一样发出新手疑问，这篇文章应该能帮到你。</p>
<span id="more"></span>

<h2 id="核心误区：建好站-能被搜到？"><a href="#核心误区：建好站-能被搜到？" class="headerlink" title="核心误区：建好站 &#x3D; 能被搜到？"></a>核心误区：建好站 &#x3D; 能被搜到？</h2><p>这是最大的误区。<strong>网站上线 ≠ 被收录。</strong></p>
<p>互联网就像一个巨大的图书馆，Google 是图书管理员。我们建好博客，只是把书写好了放在自家书房里。如果不主动去“登记”，图书管理员是不知道你这本书存在的。</p>
<p>所以，我们需要做两件事：</p>
<ol>
<li><strong>验明正身</strong>：告诉 Google 这个域名是我的（GSC 验证）。</li>
<li><strong>提交目录</strong>：把书的目录交给 Google（提交 Sitemap）。</li>
</ol>
<h2 id="第一步：注册-Google-Search-Console-GSC-："><a href="#第一步：注册-Google-Search-Console-GSC-：" class="headerlink" title="第一步：注册 Google Search Console (GSC)："></a>第一步：注册 Google Search Console (GSC)：</h2><p>Google Search Console (GSC) 是 Google 官方的站长工具。验证所有权最推荐的方法是 <strong>DNS 验证</strong>。</p>
<p>访问 <a href="https://search.google.com/search-console">Google Search Console</a></p>
<p>(1) 输入你的域名 catistrue.com (选左边的“网域”&#x2F;Domain)。</p>
<p>(2) 验证所有权：它会给你一段 TXT 代码。(复制下来就行)</p>
<p>(3) 去你的服务商（比如我是去 腾讯云 DNSPod），添加一条 TXT 记录，把代码贴进去。</p>
<h2 id="第二步：GSC-验证"><a href="#第二步：GSC-验证" class="headerlink" title="第二步：GSC 验证"></a>第二步：GSC 验证</h2><p>Google 只是想验证你拥有 <code>catistrue.com</code> 这个根域名。所以在腾讯云 DNSPod新增这样一个记录：</p>
<p>主机记录：请写 @ （或者留空不填，但在 DNSPod 里通常填 @ 代表根域名）。</p>
<p>记录类型：TXT </p>
<p>记录值：google-site-verification&#x3D;… （刚才复制下来的 TXT 代码）</p>
<hr>
<p>这里我遇到了一个新手常犯的犹豫：<strong>我已经有一条 <code>@</code> 的 A 记录指向服务器 IP 了，再加一条 <code>@</code> 的 TXT 记录用来验证，会冲突吗？</strong></p>
<p><strong>答案是：完全不会。</strong></p>
<ul>
<li><strong>A 记录</strong>：负责指路，告诉浏览器网站在哪里。</li>
<li><strong>TXT 记录</strong>：负责备注，告诉 Google 验证码是什么。</li>
</ul>
<p>只要类型不同（一个是 A，一个是 TXT），它们就能和平共处。<br>所以放心添加即可。</p>
<h2 id="第三步：最关键的-Sitemap"><a href="#第三步：最关键的-Sitemap" class="headerlink" title="第三步：最关键的 Sitemap"></a>第三步：最关键的 Sitemap</h2><p>验证通过只是拿到了“房产证”，想让爬虫快速抓取，必须主动提交 Sitemap（站点地图）。</p>
<h3 id="1-检查-Hexo-是否有-Sitemap"><a href="#1-检查-Hexo-是否有-Sitemap" class="headerlink" title="1. 检查 Hexo 是否有 Sitemap"></a>1. 检查 Hexo 是否有 Sitemap</h3><p>访问 <code>https://www.catistrue.com/sitemap.xml</code>，如果 404，说明没装插件。</p>
<p>这里插播一段，如果像我之前一样通过CI&#x2F;CD部署的，就可以感受到它的优势。</p>
<p>比如一般来说，直接通过安装本地环境搭建Hexo+GitHub的，需要在博客根目录运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>
<p>然后重新 <code>hexo g -d</code> 部署。再次访问，看到一堆密密麻麻的代码（XML 格式），就说明成功了。</p>
<p>但是，如果走CI&#x2F;CD部署的，即使手边这台电脑没有配置Node.js环境，没有配置docker环境，仍然可以很轻松给项目添加新插件。这是一个非常现实的场景。而且其实<strong>非常简单</strong>，甚至比有 Docker 还简单。</p>
<p><strong>核心逻辑是：</strong> 你只需要修改“购物清单” (<code>package.json</code>)，然后把清单传给 GitHub。真正负责“买菜做饭” (安装插件、生成页面、部署) 的是 <strong>GitHub Actions</strong>，而不是你的本地电脑。</p>
<p>你完全<strong>不需要</strong>在本地运行 <code>npm install</code> 或 <code>hexo g -d</code>。</p>
<hr>
<h4 id="操作步骤-如果已经安装过hexo-generator-sitemap插件可跳过这段"><a href="#操作步骤-如果已经安装过hexo-generator-sitemap插件可跳过这段" class="headerlink" title="操作步骤 (如果已经安装过hexo-generator-sitemap插件可跳过这段)"></a>操作步骤 (如果已经安装过<code>hexo-generator-sitemap</code>插件可跳过这段)</h4><p>对于我们这种CI&#x2F;CD部署的场景，你只需要直接编辑文件即可：</p>
<h5 id="（1）手动修改-package-json"><a href="#（1）手动修改-package-json" class="headerlink" title="（1）手动修改 package.json"></a>（1）手动修改 <code>package.json</code></h5><p>在你的项目根目录下，找到 <code>package.json</code> 文件。这是 Node.js 项目的依赖清单。</p>
<p>找到 <code>&quot;dependencies&quot;</code> 部分，手动添加一行：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;hexo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hexo-generator-archive&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hexo-generator-category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hexo-generator-index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hexo-generator-tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hexo-renderer-ejs&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hexo-renderer-marked&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^6.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hexo-renderer-stylus&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hexo-server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hexo-theme-landscape&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 👇 在这里手动加上这一行即可，版本号写 * 或者去 npm搜个大概版本都行</span></span><br><span class="line">  <span class="attr">&quot;hexo-generator-sitemap&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.0.1&quot;</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p><em>(注意：上一行的末尾别忘了加逗号 <code>,</code>，json 格式很严格)</em></p>
<h5 id="（2）配置-config-yml-如果需要"><a href="#（2）配置-config-yml-如果需要" class="headerlink" title="（2）配置 _config.yml (如果需要)"></a>（2）配置 <code>_config.yml</code> (如果需要)</h5><p>通常 sitemap 插件安装后会自动生效，但为了稳妥，我们可以在 <code>_config.yml</code> 里开启它。<br>打开根目录的 <code>_config.yml</code>，在末尾添加：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sitemap</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br></pre></td></tr></table></figure>

<h5 id="（3）提交代码"><a href="#（3）提交代码" class="headerlink" title="（3）提交代码"></a>（3）提交代码</h5><p>这就是最后一步了。我只需要把这两个文件的修改 Push 到 GitHub。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add package.json _config.yml</span><br><span class="line">git commit -m <span class="string">&quot;Add sitemap plugin&quot;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<h5 id="（4）见证奇迹"><a href="#（4）见证奇迹" class="headerlink" title="（4）见证奇迹"></a>（4）见证奇迹</h5><ol>
<li>代码推送到 GitHub 后，<strong>GitHub Actions 会自动触发</strong>。</li>
<li>Action 在云端运行时的逻辑是：<code>npm install</code>。</li>
<li>这时候，它会读取我刚才修改过的 <code>package.json</code>，发现：“咦，多了一个 <code>hexo-generator-sitemap</code>！”</li>
<li>于是它会自动下载安装这个插件。</li>
<li>接着执行 <code>hexo generate</code> 时，插件就会生效，生成 <code>sitemap.xml</code>。</li>
<li>最后部署上线。</li>
</ol>
<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>你<strong>不需要</strong>在本地安装 Node.js，也<strong>不需要</strong>运行 npm 命令。<br><strong>只要修改 <code>package.json</code> 这个纯文本文件，你就相当于指挥了云端的服务器帮你安装了插件。</strong></p>
<p>这就是 CI&#x2F;CD (持续集成&#x2F;持续部署) 的最大优势！</p>
<h3 id="2-提交给-GSC"><a href="#2-提交给-GSC" class="headerlink" title="2. 提交给 GSC"></a>2. 提交给 GSC</h3><p>在 GSC 后台找到“站点地图”，输入 <code>https://www.catistrue.com/sitemap.xml</code> 提交。</p>
<p><img src="/images/gsc/image-1.png" alt="提交站点地图"></p>
<p>到这一步提交之后，就是等待啦。</p>
<h2 id="第三步：等待"><a href="#第三步：等待" class="headerlink" title="第三步：等待"></a>第三步：等待</h2><p>提交完 Sitemap，最搞心态的一幕出现了：状态栏显示红色的 **“无法抓取” (Couldn’t fetch)**。</p>
<p>当时我也慌了，以为是 Sitemap 格式错了，或者是 Vercel 屏蔽了爬虫。</p>
<p><strong>真相是：这是 Google 的服务器延迟&#x2F;抽风。</strong><br><strong>千万别慌，不用做任何修改。</strong></p>
<p>如果你的 <code>https://www.catistrue.com/sitemap.xml</code> 能用浏览器打开，那就绝对没问题。</p>
<p>恭喜你，<strong>操作步骤已经全部完成！</strong></p>
<hr>
<h3 id="为什么会显示“无法抓取”？"><a href="#为什么会显示“无法抓取”？" class="headerlink" title="为什么会显示“无法抓取”？"></a>为什么会显示“无法抓取”？</h3><ol>
<li><strong>Pending 状态</strong>：虽然它说“无法抓取”，但实际上 Google 内部的意思往往是“pending（排队中）”。你的请求已经提交上去了，但服务器还没来得及去真的访问。</li>
<li><strong>CDN 延迟</strong>：你的网站在 Vercel 上，DNS 解析有时候会有微小的延迟，导致 Google 爬虫第一下没连上。</li>
</ol>
<h3 id="现在我们该做什么？"><a href="#现在我们该做什么？" class="headerlink" title="现在我们该做什么？"></a>现在我们该做什么？</h3><p><strong>什么都不用做，关掉页面去睡觉：P</strong></p>
<p>真的，这是解决这个红字最好的办法。</p>
<ul>
<li><strong>不要</strong> 删除它重新提交（这会让排队重置）。</li>
<li><strong>不要</strong> 怀疑你的 sitemap 有问题（只要你能用浏览器打开，它就是没问题的）。</li>
</ul>
<p>大概过了1个多小时，我再回来刷新这个页面，这个红色的“无法抓取”就会神奇地变成绿色的“成功”，或者显示出“已发现的网址数”。</p>
<p><img src="/images/gsc/image-2.png" alt="像这样"></p>
<h3 id="成功了以后，为什么我在google上搜索site-catistrue-com还是没有内容呢"><a href="#成功了以后，为什么我在google上搜索site-catistrue-com还是没有内容呢" class="headerlink" title="成功了以后，为什么我在google上搜索site:catistrue.com还是没有内容呢"></a>成功了以后，为什么我在google上搜索site:catistrue.com还是没有内容呢</h3><p><strong>这是非常正常的，千万别焦虑！</strong></p>
<p>你现在的状态就像是：<strong>刚刚把店铺的传单（Sitemap）发给了路过的推销员（Google），但他还没来得及把你的店名印到黄页（搜索结果）上。</strong></p>
<p>从“提交成功”到“搜得到”，中间还有一段 <strong>“收录期”</strong>，通常需要 <strong>数天到两周</strong> 的时间。</p>
<h3 id="为什么会这样？Google-正在后台忙这三件事："><a href="#为什么会这样？Google-正在后台忙这三件事：" class="headerlink" title="为什么会这样？Google 正在后台忙这三件事："></a>为什么会这样？Google 正在后台忙这三件事：</h3><ol>
<li><strong>发现（Discovery）</strong>：你刚提交了 Sitemap，Google 知道了“哦，这里有个新网站 <code>catistrue.com</code>”。</li>
<li><strong>抓取（Crawling）</strong>：Google 会派出爬虫（Googlebot）顺着你的 Sitemap 链接，真正地去访问你的每一个网页，下载内容。</li>
<li><strong>索引（Indexing）</strong>：爬虫把内容带回去，Google 的算法要分析你的文章质量、关键词，确定没有违规内容后，才会把它放进巨大的数据库里。</li>
</ol>
<p><strong>只有完成了第 3 步，你在 Google 搜 <code>site:catistrue.com</code> 才会出现结果。</strong></p>
<hr>
<h3 id="你现在怎么确认-Google-到底在干活没？"><a href="#你现在怎么确认-Google-到底在干活没？" class="headerlink" title="你现在怎么确认 Google 到底在干活没？"></a>你现在怎么确认 Google 到底在干活没？</h3><p>虽然搜不到，但你可以用 <strong>Google Search Console</strong> 里的一个强力工具来查看进度：</p>
<ol>
<li>在 Search Console 顶部，有一个长长的搜索框（写着“检查 catistrue.com 中的任何网址”）。</li>
<li>把你的首页地址 <code>https://catistrue.com/</code> 粘贴进去，回车。</li>
<li>系统会跑一会儿，然后给你一个报告：<ul>
<li>如果显示 <strong>“网址不在 Google 服务中”</strong>：说明爬虫还没来，或者还没处理完。（正常，继续等）</li>
<li>你可以点击灰色的按钮 <strong>“请求编入索引”</strong>。这相当于给爬虫插个队，告诉它：“哥们，这里我很急，优先来看一下。”</li>
</ul>
</li>
</ol>
<p><img src="/images/gsc/image-3.png" alt="收录成功"></p>
<p>当出现收录成功后，现在的状态：<br>你的网站已经“拿到户口本”了！<br>现在你可以放一百个心，不需要再做任何 SEO 的技术配置了。你现在唯一的任务就是：写好博客，发布出去！</p>
<h2 id="总结：从提交到收录的等待期"><a href="#总结：从提交到收录的等待期" class="headerlink" title="总结：从提交到收录的等待期"></a>总结：从提交到收录的等待期</h2><ul>
<li><strong>不要慌</strong>：新站通常需要 <strong>3天 - 1周</strong> 才能在搜索结果里冒头。</li>
<li><strong>不要改</strong>：确保你的配置是正确的，千万别因为搜不到就去乱改 DNS 或 Sitemap。</li>
<li><strong>去写文章</strong>：趁这段时间多写一两篇高质量文章，Google 爬虫第一次来如果发现内容很丰富，会对你的网站印象更好，以后收录会更快！</li>
</ul>
<p>在此期间，我们可以使用 GSC 顶部的搜索框“检查网址”，手动点击 <strong>“请求编入索引”</strong> 来给爬虫插个队。</p>
<p>剩下的，就是保持更新，静待花开。希望大家的博客都能早日出现在搜索结果的第一位！</p>
]]></content>
      <categories>
        <category>技术折腾</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>建站</tag>
        <tag>SEO</tag>
        <tag>Google Search Console</tag>
      </tags>
  </entry>
  <entry>
    <title>debian10系统原本为64位系统，如何配置32位编译and运行环境</title>
    <url>/posts/71d17bfd.html</url>
    <content><![CDATA[<h1 id="debian10系统原本为64位系统，如何配置32位编译and运行环境"><a href="#debian10系统原本为64位系统，如何配置32位编译and运行环境" class="headerlink" title="debian10系统原本为64位系统，如何配置32位编译and运行环境"></a>debian10系统原本为64位系统，如何配置32位编译and运行环境</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>原本安装的是debian10的64位系统，但是因为有些第三方程序是32位的，需要在这个系统上编译运行，那么需要配置一下必要的环境</p>
<h2 id="当32位程序放在debian64位系统里无法编译or运行时，如何判断是因为没有配置32位编译or运行环境"><a href="#当32位程序放在debian64位系统里无法编译or运行时，如何判断是因为没有配置32位编译or运行环境" class="headerlink" title="当32位程序放在debian64位系统里无法编译or运行时，如何判断是因为没有配置32位编译or运行环境"></a>当32位程序放在debian64位系统里无法编译or运行时，如何判断是因为没有配置32位编译or运行环境</h2><p>一般来说，编译32位程序时，如果出现以下报错,可以认为没有配置32位编译or运行环境</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fatal <span class="attr">error</span>: bits/libc-header-start.<span class="property">h</span>: <span class="title class_">No</span> such file or directory</span><br></pre></td></tr></table></figure>

<p>运行32位程序时，如果出现以下报错，也可以认为没有配置32位编译or运行环境</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//明明有执行程序test（32位的），但是执行./test的时候却报错</span></span><br><span class="line">test： </span><br><span class="line">     no such file or directory</span><br></pre></td></tr></table></figure>

<p>出现以上两种情况的任何一个时，一般可以判断时由于64位debian系统下，没有配置32位程序的编译or运行环境，需要执行以下两个步骤</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="一、执行sudo-apt-get-install-gcc-multilib"><a href="#一、执行sudo-apt-get-install-gcc-multilib" class="headerlink" title="一、执行sudo apt-get install gcc-multilib"></a>一、执行sudo apt-get install gcc-multilib</h3><p>安装gcc-multilib</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//安装gcc-multilib</span></span><br><span class="line">sudo apt-get install gcc-multilib</span><br></pre></td></tr></table></figure>

<h3 id="二、执行sudo-apt-get-install-g-multilib"><a href="#二、执行sudo-apt-get-install-g-multilib" class="headerlink" title="二、执行sudo apt-get install g++-multilib"></a>二、执行sudo apt-get install g++-multilib</h3><p>安装g++-multilib</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//安装g++-multilib</span></span><br><span class="line">sudo apt-get install g++-multilib</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>因为从官网直接下载下来的debian10的64位安装镜像在安装完成后，原始的debian系统是不支持32位程序运行的，所以需要对环境进行配置，所以做个记录，免得下次忘记了</p>
]]></content>
      <categories>
        <category>技术折腾</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>教程</tag>
        <tag>debian</tag>
      </tags>
  </entry>
  <entry>
    <title>git cherry-pick选择想要合并的提交</title>
    <url>/posts/9669144a.html</url>
    <content><![CDATA[<p><code>git cherry-pick</code> 用来把某些特定提交从一个分支“拣选”到当前分支，相当于“只搬你想要的那几次提交”，而不是把整个分支合并过来。</p>
<p>就是说：我只要这几个 <code>commit</code>，不要整条分支历史。</p>
<hr>
<h2 id="一、什么是-cherry-pick？"><a href="#一、什么是-cherry-pick？" class="headerlink" title="一、什么是 cherry-pick？"></a>一、什么是 <code>cherry-pick</code>？</h2><p>简单来说，<code>cherry-pick</code> 就是将某个分支上的<strong>特定提交（commit）</strong>，复制并应用到当前分支上。</p>
<p>它与 Merge 的区别在于：</p>
<ul>
<li><strong>Merge</strong>：把另一个分支的所有改动一股脑合过来。</li>
<li><strong>Cherry-pick</strong>：只把特定的某次（或某几次）提交合过来，其他的不要。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：Cherry-pick 会产生一个新的提交 SHA-1 值，虽然内容一样，但在 Git 看来这是一个全新的提交。</p>
</blockquote>
<hr>
<h2 id="二、什么时候用-cherry-pick（使用场景）"><a href="#二、什么时候用-cherry-pick（使用场景）" class="headerlink" title="二、什么时候用 cherry-pick（使用场景）"></a>二、什么时候用 <code>cherry-pick</code>（使用场景）</h2><h3 id="1-热修复回补：把线上修复同步到其它分支"><a href="#1-热修复回补：把线上修复同步到其它分支" class="headerlink" title="1. 热修复回补：把线上修复同步到其它分支"></a>1. 热修复回补：把线上修复同步到其它分支</h3><p>常见流程：</p>
<ul>
<li>在 <code>release/hotfix</code> 上修了一个 <code>bug</code> 并发布</li>
<li>需要把同样的修复回补到 <code>main</code>、<code>develop</code>（或多个维护分支）<br>这时 <code>cherry-pick</code> 比 <code>merge</code> 更直接：只带走“修复提交”，不带走其它分支差异。</li>
</ul>
<h3 id="2-挑选单个功能-提交：从别的分支拿一小段变更"><a href="#2-挑选单个功能-提交：从别的分支拿一小段变更" class="headerlink" title="2. 挑选单个功能&#x2F;提交：从别的分支拿一小段变更"></a>2. 挑选单个功能&#x2F;提交：从别的分支拿一小段变更</h3><p>例如某个 feature 分支上有一个独立的小优化提交，你当前分支也需要，但你不想把整个 feature 合并过来（因为它还没完成&#x2F;包含其它改动）。</p>
<h3 id="3-修复“提交到了错误分支”"><a href="#3-修复“提交到了错误分支”" class="headerlink" title="3. 修复“提交到了错误分支”"></a>3. 修复“提交到了错误分支”</h3><p>你本来应该把提交放到 <code>feature/a</code>，结果在 <code>feature/b</code> 上提交了：</p>
<ul>
<li>用 <code>cherry-pick</code> 把提交拣到正确分支</li>
<li>然后在错误分支上回滚&#x2F;删除（看团队策略）</li>
</ul>
<h3 id="4-分支策略限制：禁止-merge，只允许线性回补"><a href="#4-分支策略限制：禁止-merge，只允许线性回补" class="headerlink" title="4. 分支策略限制：禁止 merge，只允许线性回补"></a>4. 分支策略限制：禁止 merge，只允许线性回补</h3><p>一些团队对 <code>release</code> 分支要求很严格：只允许挑选经过验证的修复提交，禁止直接合并开发分支。<code>cherry-pick</code> 很适合这种“审计式回补”。</p>
<hr>
<h2 id="三、基本操作指南"><a href="#三、基本操作指南" class="headerlink" title="三、基本操作指南"></a>三、基本操作指南</h2><h3 id="1-挑选单个提交（最常用）"><a href="#1-挑选单个提交（最常用）" class="headerlink" title="1. 挑选单个提交（最常用）"></a>1. 挑选单个提交（最常用）</h3><p>假设你想把 <code>feature</code> 分支上的提交 <code>a1b2c3d</code> 应用到 <code>main</code> 分支。</p>
<ol>
<li><strong>切换到目标分支</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git switch main</span><br></pre></td></tr></table></figure></li>
<li><strong>执行 cherry-pick</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick a1b2c3d</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-挑选多个提交"><a href="#2-挑选多个提交" class="headerlink" title="2. 挑选多个提交"></a>2. 挑选多个提交</h3><h4 id="挑选不连续的多个提交："><a href="#挑选不连续的多个提交：" class="headerlink" title="挑选不连续的多个提交："></a>挑选不连续的多个提交：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick commit_id_1 commit_id_2</span><br></pre></td></tr></table></figure>
<p>这会按顺序一次应用这两个提交。</p>
<h4 id="挑选连续的一段提交（区间）："><a href="#挑选连续的一段提交（区间）：" class="headerlink" title="挑选连续的一段提交（区间）："></a>挑选连续的一段提交（区间）：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick start_commit_id^..end_commit_id</span><br></pre></td></tr></table></figure>
<ul>
<li>注意中间是两个点 <code>..</code>。</li>
<li><code>start_commit_id^</code> 表示包含起始提交（如果不加 <code>^</code> 就不包含起始提交，这是 Git 区间的特性）。</li>
</ul>
<h3 id="3-挑选提交但不立即提交（只拿代码）"><a href="#3-挑选提交但不立即提交（只拿代码）" class="headerlink" title="3. 挑选提交但不立即提交（只拿代码）"></a>3. 挑选提交但不立即提交（只拿代码）</h3><p>如果你只想把改动拿过来，放在暂存区（Staged），不想自动生成 Commit，可以加 <code>-n</code> 或 <code>--no-commit</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick -n a1b2c3d</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>场景</strong>：你想拿过来改点东西再提交，或者你想把多个 cherry-pick 的改动合并成一个新的提交。</li>
</ul>
<hr>
<h2 id="四、冲突处理"><a href="#四、冲突处理" class="headerlink" title="四、冲突处理"></a>四、冲突处理</h2><p>Cherry-pick 本质上也是一种合并操作，所以<strong>非常容易遇到冲突</strong>。</p>
<p>当执行 <code>git cherry-pick</code> 遇到冲突时，Git 会暂停操作。你需要解决冲突：</p>
<ol>
<li><strong>查看冲突文件</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></li>
<li><strong>手动解决冲突</strong>（编辑代码，保留你想要的部分）。</li>
<li><strong>标记冲突已解决</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add &lt;path/to/conflict-file&gt;</span><br></pre></td></tr></table></figure></li>
<li><strong>继续执行 cherry-pick</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure>
<em>(此时不需要 <code>git commit</code>，该命令会自动弹窗让你编辑提交信息并生成提交)</em></li>
</ol>
<h4 id="如果想放弃-cherry-pick："><a href="#如果想放弃-cherry-pick：" class="headerlink" title="如果想放弃 cherry-pick："></a>如果想放弃 cherry-pick：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick --abort</span><br></pre></td></tr></table></figure>
<p>这会回到操作前的状态。</p>
<hr>
<h2 id="五、技巧与注意事项"><a href="#五、技巧与注意事项" class="headerlink" title="五、技巧与注意事项"></a>五、技巧与注意事项</h2><h3 id="1-保留原作者信息"><a href="#1-保留原作者信息" class="headerlink" title="1. 保留原作者信息"></a>1. 保留原作者信息</h3><p>Cherry-pick 默认会保留原提交的作者（Author）信息，但提交者（Committer）会变成你。这通常是期望的行为。</p>
<h3 id="2-加上来源标记-x"><a href="#2-加上来源标记-x" class="headerlink" title="2. 加上来源标记 (-x)"></a>2. 加上来源标记 (<code>-x</code>)</h3><p>如果你想在提交信息里记录这个提交是从哪里摘过来的，可以加 <code>-x</code> 参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick -x a1b2c3d</span><br></pre></td></tr></table></figure>
<p>提交信息末尾会自动添加一行：<code>(cherry picked from commit a1b2c3d...)</code>。</p>
<blockquote>
<p><strong>建议</strong>：在团队协作中，加上 <code>-x</code> 是个好习惯，方便溯源。</p>
</blockquote>
<h3 id="3-避免频繁-Cherry-pick"><a href="#3-避免频繁-Cherry-pick" class="headerlink" title="3. 避免频繁 Cherry-pick"></a>3. 避免频繁 Cherry-pick</h3><p>虽然好用，但不要滥用。如果你发现自己在频繁地在分支间倒腾提交，说明你的<strong>分支策略</strong>可能出了问题。频繁 Cherry-pick 会导致产生大量重复内容的提交（Duplicate Commits），增加未来合并时的冲突风险。</p>
<hr>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git cherry-pick &lt;commit-hash&gt;</code></td>
<td align="left">把指定提交应用到当前分支</td>
</tr>
<tr>
<td align="left"><code>git cherry-pick -x &lt;commit-hash&gt;</code></td>
<td align="left">应用并自动追加来源说明（推荐）</td>
</tr>
<tr>
<td align="left"><code>git cherry-pick -n &lt;commit-hash&gt;</code></td>
<td align="left">应用改动但不生成提交（只放暂存区）</td>
</tr>
<tr>
<td align="left"><code>git cherry-pick --continue</code></td>
<td align="left">解决冲突后继续</td>
</tr>
<tr>
<td align="left"><code>git cherry-pick --abort</code></td>
<td align="left">放弃操作，回退</td>
</tr>
</tbody></table>
<p><code>Cherry-pick</code>，能让你在处理紧急修复、特定功能迁移时非常方便。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>本地配置多个git账号</title>
    <url>/posts/aedc60d4.html</url>
    <content><![CDATA[<p>有时候，需要在一个电脑上管理多个 Git 账号（比如一个是 GitLab，一个是 GitHub，或者两个都是 GitHub 账号）是一个比较常见的场景。</p>
<p>如果不配置好，很容易出现“用错账号提交代码”或者“没权限推送代码”的尴尬情况。</p>
<p>最优雅、最推荐的方案是使用 <strong>SSH Config + 文件夹别名</strong> 的方式。</p>
<p>下面是手把手的配置指南：</p>
<h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><ol>
<li><strong>生成两把钥匙</strong>：为每个账号生成不同的 SSH Key。</li>
<li><strong>告诉 SSH 怎么选</strong>：配置 <code>~/.ssh/config</code> 文件，让 SSH 知道访问不同主机时用哪把钥匙。</li>
<li><strong>告诉 Git 怎么选</strong>：(可选但推荐) 通过文件夹路径自动切换用户名和邮箱。</li>
</ol>
<hr>
<h3 id="第一步：生成两对-SSH-Key"><a href="#第一步：生成两对-SSH-Key" class="headerlink" title="第一步：生成两对 SSH Key"></a>第一步：生成两对 SSH Key</h3><p>打开终端（Terminal 或 Git Bash），分别生成两个 SSH Key。<br><strong>注意要给文件起不同的名字！</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 生成账号1的 Key (假设是 GitHub)</span></span><br><span class="line">ssh-keygen -t ed25519 -C <span class="string">&quot;你的邮箱1@gmail.com&quot;</span> -f ~/.ssh/id_ed25519_gmail</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 生成账号2的 Key (假设是 GitLab)</span></span><br><span class="line">ssh-keygen -t ed25519 -C <span class="string">&quot;你的邮箱2@mail.163.com&quot;</span> -f ~/.ssh/id_ed25519_163</span><br></pre></td></tr></table></figure>
<p><em>(如果系统不支持 ed25519，可以用 <code>-t rsa -b 4096</code> 代替)</em></p>
<p>现在你的 <code>~/.ssh/</code> 目录下应该有 4 个文件（两个私钥无后缀，两个公钥带 <code>.pub</code>）。</p>
<h3 id="第二步：把公钥添加到对应的平台"><a href="#第二步：把公钥添加到对应的平台" class="headerlink" title="第二步：把公钥添加到对应的平台"></a>第二步：把公钥添加到对应的平台</h3><ol>
<li><strong>账号1</strong>：复制 <code>id_ed25519_gmail.pub</code> 的内容 -&gt; 去 GitHub -&gt; Settings -&gt; SSH and GPG keys -&gt; New SSH key。</li>
<li><strong>账号2</strong>：复制 <code>id_ed25519_163.pub</code> 的内容 -&gt; 去 GitLab -&gt; Settings -&gt; SSH Keys。</li>
</ol>
<h3 id="第三步：配置-SSH-Config-最关键的一步"><a href="#第三步：配置-SSH-Config-最关键的一步" class="headerlink" title="第三步：配置 SSH Config (最关键的一步)"></a>第三步：配置 SSH Config (最关键的一步)</h3><p>在 <code>~/.ssh/</code> 目录下创建一个名为 <code>config</code> 的文件（如果没有的话）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建或编辑 config 文件</span></span><br><span class="line">code ~/.ssh/config</span><br></pre></td></tr></table></figure>

<p><strong>将以下内容填入文件中：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># --- 账号1 (GitHub) ---</span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~/.ssh/id_ed25519_gmail</span><br><span class="line"></span><br><span class="line"># --- 账号2 (假设是 GitLab) ---</span><br><span class="line"># 注意：这里的 Host 起了个别名，叫 gitlab-123</span><br><span class="line">Host gitlab-123</span><br><span class="line">    HostName gitlab.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~/.ssh/id_ed25519_163</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong> 如果两个账号都是 GitHub，你需要给第二个 Host 起个别名，比如 <code>Host github-123</code>，下面的 <code>HostName</code> 依然填 <code>github.com</code>。</p>
</blockquote>
<h3 id="第四步：解决用户名和邮箱自动切换-可选但更方便"><a href="#第四步：解决用户名和邮箱自动切换-可选但更方便" class="headerlink" title="第四步：解决用户名和邮箱自动切换 (可选但更方便)"></a>第四步：解决用户名和邮箱自动切换 (可选但更方便)</h3><p>一种方法是你每次 clone 下来后手动设置 <code>git config user.name</code>，不过这很容易忘掉这个步骤。</p>
<p>另一种方法就是接下来，我们可以利用 Git 的 <strong>“includeIf”</strong> 功能，根据文件夹路径自动切换配置。</p>
<ol>
<li><p><strong>规划文件夹</strong>：</p>
<ul>
<li>在电脑里建一个文件夹叫 <code>~/Code/GMail</code> (放项目1)</li>
<li>建另一个文件夹叫 <code>~/Code/Mail163</code> (放项目2)</li>
</ul>
</li>
<li><p><strong>创建特定的 .gitconfig 文件</strong>：</p>
<ul>
<li>创建 <code>~/.gitconfig-gmail</code>，内容如下：<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[user]</span></span><br><span class="line">    <span class="attr">name</span> = 昵称<span class="number">1</span></span><br><span class="line">    <span class="attr">email</span> = 邮箱<span class="number">1</span>@gmail.com</span><br></pre></td></tr></table></figure></li>
<li>创建 <code>~/.gitconfig-123</code>，内容如下：<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[user]</span></span><br><span class="line">    <span class="attr">name</span> = 昵称<span class="number">2</span></span><br><span class="line">    <span class="attr">email</span> = 邮箱<span class="number">2</span>@mail.<span class="number">163</span>.com</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**修改主配置文件 <code>~/.gitconfig</code>**：<br>打开全局的 <code>~/.gitconfig</code>，在最下面加入：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果路径包含 ~/Code/GMail/，就引用配置1</span></span><br><span class="line"><span class="section">[includeIf &quot;gitdir:~/Code/GMail/&quot;]</span></span><br><span class="line">    <span class="attr">path</span> = ~/.gitconfig-gmail</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果路径包含 ~/Code/Mail163/，就引用配置2</span></span><br><span class="line"><span class="section">[includeIf &quot;gitdir:~/Code/Mail163/&quot;]</span></span><br><span class="line">    <span class="attr">path</span> = ~/.gitconfig-<span class="number">123</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="第五步：验证效果"><a href="#第五步：验证效果" class="headerlink" title="第五步：验证效果"></a>第五步：验证效果</h3><ol>
<li><p><strong>测试连接</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line"><span class="comment"># 应该显示：Hi [账号1]! You&#x27;ve successfully authenticated...</span></span><br><span class="line"></span><br><span class="line">ssh -T git@gitlab-123</span><br><span class="line"><span class="comment"># 应该显示：Welcome to GitLab, [账号2]!</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>平时使用</strong>：</p>
<ul>
<li><strong>项目1</strong>：正常 clone 即可。<br><code>git clone git@github.com:user/repo.git</code></li>
<li><strong>项目2</strong>：如果你在 config 里用了别名（比如上面把公司 GitLab 叫 <code>gitlab-123</code>），clone 的时候要稍微改一下地址：<br><code>git clone git@gitlab-123:group/project.git</code><br><em>(把原本的域名换成你在 config 里写的 Host 别名)</em></li>
</ul>
</li>
</ol>
<p>这样配置后，只要你在 <code>~/Code/GMail</code> 目录下操作，提交记录自动就是邮箱1；在 <code>~/Code/Mail163</code> 下操作，自动就是邮箱2。完美兼容！</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git Rebase与交互式变基</title>
    <url>/posts/ae152b94.html</url>
    <content><![CDATA[<p>在 Git 的世界里，<code>git rebase</code>（变基）大概是最常用的命令之一。</p>
<p>很多人因为害怕“把代码搞丢”而只敢用 <code>git merge</code>，导致提交历史里充斥着无意义的 <code>Merge branch &#39;master&#39; into feature</code> 节点，或者像蚯蚓一样弯弯曲曲的分支线。</p>
<p>但是如果使用 <code>git rebase</code>，就会把你的提交历史变成一条优雅的直线。</p>
<p>rebase 的核心作用：把一串提交“搬家”到新的基底上，从而让提交历史更线性、更易读。你可以把它理解为：把分支上的提交“重放”到另一个分支（或另一个提交）之后。</p>
<hr>
<h2 id="一、-核心概念：Rebase-到底是在干什么？"><a href="#一、-核心概念：Rebase-到底是在干什么？" class="headerlink" title="一、 核心概念：Rebase 到底是在干什么？"></a>一、 核心概念：Rebase 到底是在干什么？</h2><p>简单来说，<strong>Rebase &#x3D; 重新（Re）定义起点（Base）。</strong></p>
<p>想象一下，你从 <code>master</code> 分支切出了一个 <code>feature</code> 分支写代码。<br>在你写代码的几天里，同事向 <code>master</code> 推送了新代码。此时，你的 <code>feature</code> 分支的“地基”已经过时了。</p>
<h3 id="Merge-vs-Rebase"><a href="#Merge-vs-Rebase" class="headerlink" title="Merge vs Rebase"></a>Merge vs Rebase</h3><ul>
<li>**Merge (合并)**：保留所有历史，创建一个新的“合并节点”。就像把两条河流汇聚在一起，虽然真实，但如果合并频繁，历史线会变得像蜘蛛网一样乱。</li>
<li><strong>Rebase (变基)<strong>：把你在这个分支上的所有修改“剪”下来，然后贴到 <code>master</code> 的最新位置后面。就像你时光倒流，假装你的代码是</strong>刚刚</strong>基于最新的 <code>master</code> 写出来的。</li>
</ul>
<p><strong>结果：你的历史线变成了一条干净的直线。</strong></p>
<hr>
<h2 id="二、-场景一：同步上游代码-不用-i"><a href="#二、-场景一：同步上游代码-不用-i" class="headerlink" title="二、 场景一：同步上游代码 (不用 -i)"></a>二、 场景一：同步上游代码 (不用 <code>-i</code>)</h2><p><strong>场景</strong>：你在开发 <code>feature</code> 分支，准备提 Pull Request，但发现 <code>master</code> 已经更新了。为了避免冲突，或者为了让提交历史好看，你需要把 <code>master</code> 的新代码同步过来。</p>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 切换到master，把最新的代码同步过来</span></span><br><span class="line">git checkout master</span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 再切换到你的开发分支</span></span><br><span class="line">git checkout feature</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 执行变基（把 feature 接到 master 的最前面）</span></span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure>

<h3 id="可能会发生什么？"><a href="#可能会发生什么？" class="headerlink" title="可能会发生什么？"></a>可能会发生什么？</h3><p>如果一切顺利，Git 会自动搞定。但通常会遇到冲突（Conflict）。此时 Git 会停下来让你解决。</p>
<p><strong>解决冲突流程：</strong></p>
<ol>
<li>打开代码编辑器，手动解决冲突文件。</li>
<li>将解决后的文件放入暂存区：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add &lt;文件名&gt;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意：不要 commit！</strong> 而是告诉 rebase 继续：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>(如果你中途后悔了，想放弃变基，执行 <code>git rebase --abort</code> 即可回到操作前。)</p>
<hr>
<h2 id="三、-场景二：整理提交历史-使用-i"><a href="#三、-场景二：整理提交历史-使用-i" class="headerlink" title="三、 场景二：整理提交历史 (使用 -i)"></a>三、 场景二：整理提交历史 (使用 <code>-i</code>)</h2><p>这是 Rebase 最神的地方。</p>
<p><strong>场景</strong>：你在开发某个功能，为了保存进度，你可能提交了这样的 Log：</p>
<ul>
<li><code>feat: 完成登录功能</code></li>
<li><code>fix: 修复一个拼写错误</code></li>
<li><code>wip: 还没写完，先存一下</code></li>
<li><code>fix: 刚才有个 bug 没改对</code></li>
</ul>
<p>这堆乱七八糟的提交如果推送到公司仓库，会被同事鄙视的。你需要把这 4 个提交合并成 <strong>1 个</strong> 完美的提交。</p>
<h3 id="操作步骤-1"><a href="#操作步骤-1" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>假设我们要整理最近的 4 次提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~4</span><br></pre></td></tr></table></figure>

<p>这里的 <code>-i</code> 代表 <strong>Interactive（交互式）</strong>。</p>
<h3 id="交互界面怎么玩？"><a href="#交互界面怎么玩？" class="headerlink" title="交互界面怎么玩？"></a>交互界面怎么玩？</h3><p>输入命令后，Git 会自动打开 Vim（或你配置的编辑器），内容大概长这样：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pick 1a2b3c4 feat: 完成登录功能</span><br><span class="line">pick 5d6e7f8 fix: 修复一个拼写错误</span><br><span class="line">pick 9g0h1i2 wip: 还没写完，先存一下</span><br><span class="line">pick 3j4k5l6 fix: 刚才有个 bug 没改对</span><br><span class="line"></span><br><span class="line"># Commands:</span><br><span class="line"># p, pick = use commit (保留该提交)</span><br><span class="line"># r, reword = use commit, but edit the commit message (保留提交，但修改注释)</span><br><span class="line"># s, squash = use commit, but meld into previous commit (合并到上一个提交)</span><br><span class="line"># f, fixup = like &quot;squash&quot;, but discard this commit&#x27;s log message (合并但丢弃注释)</span><br><span class="line"># d, drop = remove commit (删除该提交)</span><br></pre></td></tr></table></figure>

<p><strong>你的任务是修改每一行开头的单词：</strong></p>
<p>我们想把后面 3 个都“挤”进第 1 个里，所以修改如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pick 1a2b3c4 feat: 完成登录功能</span><br><span class="line">s 5d6e7f8 fix: 修复一个拼写错误</span><br><span class="line">s 9g0h1i2 wip: 还没写完，先存一下</span><br><span class="line">s 3j4k5l6 fix: 刚才有个 bug 没改对</span><br></pre></td></tr></table></figure>

<p>保存并退出（Vim 中按 <code>Esc</code> 然后输入 <code>:wq</code>）。</p>
<p>Git 会弹出第二个编辑器窗口，让你编写合并后的 <strong>最终 Commit Message</strong>。修改完保存退出，你的 4 个提交就变成 1 个了！</p>
<hr>
<h2 id="四、-黄金法则：绝对不要-Rebase-公共分支！"><a href="#四、-黄金法则：绝对不要-Rebase-公共分支！" class="headerlink" title="四、 黄金法则：绝对不要 Rebase 公共分支！"></a>四、 黄金法则：绝对不要 Rebase 公共分支！</h2><p>这是使用 Rebase 唯一的、绝对的红线。</p>
<p><strong>原则：</strong></p>
<blockquote>
<p>只有当这个分支 <strong>只有你一个人在用</strong>（还是本地分支）时，你才能随便 Rebase。</p>
</blockquote>
<p><strong>为什么？</strong><br>Rebase 会修改提交的 Hash ID（因为它重写了历史）。<br>如果你把 <code>master</code> 分支或者同事正在开发的 <code>feature-shared</code> 分支给 Rebase 了，同事那边的代码就会和远程仓库彻底对不上号，导致灾难级的冲突。</p>
<p><strong>一句话总结：已推送到远程且有人协作的分支，老老实实用 Merge；本地自己玩的分支，大胆用 Rebase。</strong></p>
<hr>
<h2 id="五、-总结"><a href="#五、-总结" class="headerlink" title="五、 总结"></a>五、 总结</h2><table>
<thead>
<tr>
<th align="left">需求</th>
<th align="left">命令</th>
<th align="left">效果</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>同步 master 代码</strong></td>
<td align="left"><code>git rebase master</code></td>
<td align="left">你的分支基于最新的 master，历史是一条直线。</td>
</tr>
<tr>
<td align="left"><strong>合并琐碎提交</strong></td>
<td align="left"><code>git rebase -i HEAD~N</code></td>
<td align="left">进入交互模式，使用 <code>squash</code> 压缩 N 个提交。</td>
</tr>
<tr>
<td align="left"><strong>修改某次提交信息</strong></td>
<td align="left"><code>git rebase -i HEAD~N</code></td>
<td align="left">进入交互模式，使用 <code>reword</code> 修改注释。</td>
</tr>
<tr>
<td align="left"><strong>删除某次提交</strong></td>
<td align="left"><code>git rebase -i HEAD~N</code></td>
<td align="left">进入交互模式，使用 <code>drop</code> 丢弃某次提交。</td>
</tr>
<tr>
<td align="left"><strong>变基失败想重来</strong></td>
<td align="left"><code>git rebase --abort</code></td>
<td align="left">回到变基之前的状态，无事发生。</td>
</tr>
</tbody></table>
<p>学会 Git Rebase，是提高使用git效率的必经之路~</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>技术折腾</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Hexo</tag>
        <tag>博客搭建</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始：使用 Docker + Hexo + Vercel + 腾讯云域名搭建个人博客</title>
    <url>/posts/e09a1826.html</url>
    <content><![CDATA[<p>终于拥有了自己的独立域名博客！🎉</p>
<p>这篇博客记录了我从零开始搭建 <code>catistrue.com</code> 的全过程。</p>
<p>在这场折腾中，我本来想直接用<strong>Hexo+GitHub Page</strong>方案。但是考虑到我有多台电脑，有时候会随机打开某一台开始工作，难道我要每一台都配置<strong>Node.js</strong>等等各种环境？<br>经过我的研究，对于我这种情况，最完美的方案是采用 “本地 Docker 预览 + GitHub Actions 自动构建 + 阿里云加速镜像” 的架构。</p>
<p><strong>这个时候，我的核心思路：CI&#x2F;CD 自动化流</strong></p>
<p>不要在任何一台电脑上执行 hexo d（部署命令）。所有的部署工作都交给云端自动化完成。<br>    多台电脑：只负责写 Markdown 文章，然后 git push。<br>    GitHub：负责存储源码，并通过 GitHub Actions 自动生成静态页面。<br>    阿里云：作为国内访问的“加速节点”或“镜像站”。</p>
<p>为了保证我在任何一台电脑上都能无缝切换，同时利用阿里云加速，我开始按照 <strong>“本地环境 -&gt; 代码仓库 -&gt; 自动化构建 -&gt; 双路部署”</strong> 的顺序来搭建。</p>
<hr>
<h3 id="第一阶段：初始化项目与本地环境"><a href="#第一阶段：初始化项目与本地环境" class="headerlink" title="第一阶段：初始化项目与本地环境"></a>第一阶段：初始化项目与本地环境</h3><p><strong>目标：</strong> 在我顺手打开的这台电脑上，用 Docker 初始化 Hexo，并建立 Git 仓库。</p>
<h4 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h4><p>我的电脑上已经安装了：</p>
<ul>
<li><strong>Docker Desktop</strong>（最好配置Docker镜像加速器，否则非常慢）</li>
<li><strong>Git</strong></li>
<li>拥有一个 GitHub 账号</li>
</ul>
<h4 id="2-初始化-Hexo-文件（使用-Docker）"><a href="#2-初始化-Hexo-文件（使用-Docker）" class="headerlink" title="2. 初始化 Hexo 文件（使用 Docker）"></a>2. 初始化 Hexo 文件（使用 Docker）</h4><p>打开终端（Windows 下建议用 PowerShell 或 Git Bash），进入我想存放博客的目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 创建博客目录</span></span><br><span class="line"><span class="built_in">mkdir</span> my-blog</span><br><span class="line"><span class="built_in">cd</span> my-blog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 使用临时 Docker 容器初始化 Hexo (无需本地安装 Node)</span></span><br><span class="line"><span class="comment"># 注意：这一步会下载 node 镜像并安装 hexo，可能需要一点时间</span></span><br><span class="line"><span class="comment"># 最好预先配置一下 Docker 镜像加速器</span></span><br><span class="line">docker run --<span class="built_in">rm</span> -v <span class="string">&quot;<span class="subst">$(pwd)</span>:/app&quot;</span> -w /app node:18-alpine sh -c <span class="string">&quot;npm install hexo-cli -g &amp;&amp; hexo init .&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 补充安装 npm 依赖</span></span><br><span class="line">docker run --<span class="built_in">rm</span> -v <span class="string">&quot;<span class="subst">$(pwd)</span>:/app&quot;</span> -w /app node:18-alpine npm install</span><br></pre></td></tr></table></figure>

<h4 id="3-创建本地环境配置"><a href="#3-创建本地环境配置" class="headerlink" title="3. 创建本地环境配置"></a>3. 创建本地环境配置</h4><p>在 <code>my-blog</code> 根目录下创建一个 <code>docker-compose.yml</code> 文件。这是你<strong>多台电脑同步</strong>的核心：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">hexo:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">node:18-alpine</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hexo-dev</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/app</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./:/app</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;4000:4000&quot;</span></span><br><span class="line">    <span class="comment"># 启动时自动安装新依赖，并开启预览服务器</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">-c</span> <span class="string">&quot;npm install &amp;&amp; npx hexo server -p 4000 -i 0.0.0.0&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-测试本地运行"><a href="#4-测试本地运行" class="headerlink" title="4. 测试本地运行"></a>4. 测试本地运行</h4><p>在终端运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure>
<p>访问 <code>http://localhost:4000</code>。如果看到 Hexo 的默认页面，说明本地环境搭建成功。按 <code>Ctrl+C</code> 停止。</p>
<hr>
<h3 id="第二阶段：推送到-GitHub-并配置自动化"><a href="#第二阶段：推送到-GitHub-并配置自动化" class="headerlink" title="第二阶段：推送到 GitHub 并配置自动化"></a>第二阶段：推送到 GitHub 并配置自动化</h3><p><strong>目标：</strong> 将源码上传，并让 GitHub Actions 接管构建任务。</p>
<h4 id="1-创建-GitHub-仓库"><a href="#1-创建-GitHub-仓库" class="headerlink" title="1. 创建 GitHub 仓库"></a>1. 创建 GitHub 仓库</h4><ul>
<li>在 GitHub 创建一个新仓库，命名为 <code>你的用户名.github.io</code> (要设置为<code>Public</code>，我一开始设置为私有仓库，结果发现免费账号无法直接在私有仓库中使用 GitHub Pages)。</li>
</ul>
<h4 id="2-提交代码"><a href="#2-提交代码" class="headerlink" title="2. 提交代码"></a>2. 提交代码</h4><p>在 <code>my-blog</code> 目录下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成 .gitignore (Hexo 初始化时通常已有，确认包含 node_modules, public, db.json)</span></span><br><span class="line">git init</span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin &lt;你的仓库SSH地址&gt;</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;Initialize blog&quot;</span></span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<h4 id="3-配置-GitHub-Pages-部署流程"><a href="#3-配置-GitHub-Pages-部署流程" class="headerlink" title="3. 配置 GitHub Pages 部署流程"></a>3. 配置 GitHub Pages 部署流程</h4><p>在项目根目录创建路径 <code>.github/workflows/deploy.yml</code>，填入以下内容。<br><em>注意：此时我们先只配置 GitHub Pages，确保跑通后再加阿里云&#x2F;腾讯云。</em></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Blog</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span> <span class="comment"># 监听 main 分支的改动</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">source</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&#x27;18&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">Hexo</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npx</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">GitHub</span> <span class="string">Pages</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">github_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>提交这个文件并 Push。</strong></p>
<p>去 GitHub 仓库的 <code>Actions</code> 标签页，查看是否构建成功。</p>
<p><img src="/images/image-1.png" alt="如果构建失败"></p>
<p>为了看更详细的失败原因，可以去 GitHub 仓库的 Actions 标签页，点击那个红色的失败任务，点击左侧的 build。<br><img src="/images/image-2.png" alt="查看详细失败原因"></p>
<p>网上查了一下这个报错 <code>sh: 1: hexo: Permission denied</code> 结合 <code>Exit code 127</code>，发现是因为<strong>把 Windows 下生成的 <code>node_modules</code> 文件夹上传到 GitHub 了。</strong></p>
<h5 id="研究了一下为什么会报错？"><a href="#研究了一下为什么会报错？" class="headerlink" title="研究了一下为什么会报错？"></a>研究了一下为什么会报错？</h5><ol>
<li>我在本地（Windows 或 Docker 挂载的 Windows 目录）生成了 <code>node_modules</code>。</li>
<li>Windows 下的可执行文件权限和 Linux（GitHub Actions 运行环境）是不兼容的。</li>
<li>当我把这些文件推送到 GitHub，Actions 在 Linux 环境下尝试运行 <code>node_modules</code> 里的 <code>hexo</code> 命令时，发现文件权限不对，或者格式不对，于是报“拒绝访问”。</li>
</ol>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>如果你也遇到了一样的问题，解决方法也很简单，只需要<strong>从 Git 仓库中删除 <code>node_modules</code>，并让 GitHub Actions 自己重新下载安装。</strong></p>
<p>打开<strong>本地电脑</strong>的终端，进入博客目录，依次执行以下命令：</p>
<p>（1）第一步：修改 .gitignore<br>确保你的目录里有一个 <code>.gitignore</code> 文件。<br>如果没有，新建一个；如果有，确保里面包含 <code>node_modules</code>。<br>可以使用命令追加：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Windows PowerShell 下追加内容（如果文件不存在会自动创建）</span></span><br><span class="line"><span class="built_in">Add-Content</span> .gitignore <span class="string">&quot;node_modules/&quot;</span></span><br><span class="line"><span class="built_in">Add-Content</span> .gitignore <span class="string">&quot;public/&quot;</span></span><br><span class="line"><span class="built_in">Add-Content</span> .gitignore <span class="string">&quot;db.json&quot;</span></span><br></pre></td></tr></table></figure>

<p>（2）第二步：从 Git 记录中删除这些文件<br>这一步很重要，<strong>不要直接在文件管理器删文件夹</strong>，我们要的是从“Git 的追踪记录”里删除，但保留你本地的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 从 Git 暂存区删除 node_modules (不会删除你本地的实体文件)</span></span><br><span class="line">git <span class="built_in">rm</span> -r --cached node_modules</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 顺便把生成的 public 也删了，源码库不需要存生成后的网页</span></span><br><span class="line">git <span class="built_in">rm</span> -r --cached public</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 提交更改</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;Fix: remove node_modules from git tracking&quot;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>（3）第三步：去 GitHub Actions 查看<br>当你执行完 <code>git push</code> 后，GitHub Actions 会自动触发一次新的构建。<br>这次，它在 <code>Install Dependencies</code> 这一步会下载全新的、适配 Linux 环境的依赖包，<code>hexo generate</code> 就不会报错了。</p>
<hr>
<p>成功后，可以去仓库 <code>Settings -&gt; Pages</code>，将 source 改为 <code>gh-pages</code> 分支。<br>此时我的博客已经可以通过 <code>https://catistrue.github.io/</code> 访问了。</p>
<hr>
<h3 id="第三阶段：抉择时刻：阿里云or腾讯云"><a href="#第三阶段：抉择时刻：阿里云or腾讯云" class="headerlink" title="第三阶段：抉择时刻：阿里云or腾讯云"></a>第三阶段：抉择时刻：阿里云or腾讯云</h3><p>鉴于我的具体需求: “个人博客 + Docker 部署 + 需要国内访问加速” ，到底是选择腾讯云还是阿里云，我纠结了一下。经过我翻看各大网友的建议，作为个人博主，我最后决定选择腾讯云，它够轻量也够用了，省下来的钱和带宽，对个人博客来说才是实打实的。</p>
<p>而且，我可以通过 腾讯云 DNS + Vercel ，个人版够用。</p>
<p>于是，我现在的架构是 “基于 Serverless 的现代化博客架构：本地 Hexo + Git 版本控制 + Vercel 边缘网络自动部署 + 腾讯云 DNS 解析” （据说是全球最流行的 JAMstack 架构，在技术圈里是非常时髦的！）（这个说法我还没有考证过，欢迎各位小伙伴解答。）</p>
<hr>
<h3 id="第四阶段：腾讯云购买域名的保姆级教程"><a href="#第四阶段：腾讯云购买域名的保姆级教程" class="headerlink" title="第四阶段：腾讯云购买域名的保姆级教程"></a>第四阶段：腾讯云购买域名的保姆级教程</h3><p>整个过程大概需要 <strong>15-20 分钟</strong>，主要时间花在“实名认证”的审核上。</p>
<h4 id="（1）-准备工作"><a href="#（1）-准备工作" class="headerlink" title="（1） 准备工作"></a>（1） 准备工作</h4><ol>
<li><strong>账号准备</strong>：注册并登录腾讯云账号（可以用微信直接扫码登录，最方便）。</li>
<li><strong>身份认证</strong>：这是国家规定必须做的。<ul>
<li>登录后，系统通常会提示你进行 <strong>“实名认证”</strong>。</li>
<li>做个人博客，所以我选择 <strong>“个人认证”</strong> </li>
<li><em>注意：这一步是绑定你的身份信息，为了合规。</em></li>
</ul>
</li>
</ol>
<hr>
<h4 id="（2）挑选并购买域名"><a href="#（2）挑选并购买域名" class="headerlink" title="（2）挑选并购买域名"></a>（2）挑选并购买域名</h4><ol>
<li><p><strong>进入域名注册页面</strong>：</p>
<ul>
<li>在腾讯云官网首页搜索栏输入 <strong>“域名注册”</strong>，点击进入。</li>
<li>或者直接访问：<code>https://dnspod.cloud.tencent.com/</code></li>
</ul>
</li>
<li><p><strong>搜索心仪的域名</strong>：</p>
<ul>
<li>在搜索框输入你想好的名字（比如 <code>CatIsTrue</code>）。</li>
<li>点击查询，系统会列出哪些后缀（.com &#x2F; .cn &#x2F; .net）还能买，以及价格。</li>
</ul>
</li>
<li><p><strong>选择与购买</strong>：</p>
<ul>
<li><strong>强烈建议</strong>：首选 **<code>.com</code>**（最通用、看着专业），如果为了便宜也可以选 <code>.cn</code>（必须实名且有些限制），或者 <code>.net</code>。</li>
<li>看到“未注册”字样，点击右侧的 <strong>“加入购物车”</strong> -&gt; <strong>“立即购买”</strong>。</li>
<li>对于个人博客网站来说，只买<code>.com</code>就够了，不用看它绑定的一堆组合（省杯咖啡钱）</li>
</ul>
</li>
<li><p><strong>填写域名信息模板（关键步骤）</strong>：</p>
<ul>
<li>购买界面会让你选择 <strong>“域名信息模板”</strong>。如果像我一样是第一次买，还需要点击 <strong>“创建新模板”</strong>。</li>
<li><strong>填写信息</strong>：填写真实的姓名、邮箱、地址、手机号。</li>
<li><strong>实名核验</strong>：这里需要再次上传你的<strong>身份证正面照片</strong>（只正面就行了）。</li>
<li>提交后，腾讯云会审核这个模板（通常 1-10 分钟内完成）。</li>
<li><em>审核通过后，回到购买页面，勾选这个模板。</em></li>
<li><em>注意：如果是还在审核中，是不能购买下单的，等它审核结束就行。差不多3-5分钟就完成了，审核很快</em></li>
</ul>
</li>
<li><p><strong>隐私保护（重要！）</strong>：</p>
<ul>
<li>在结算页面，留意有没有 <strong>“域名隐私保护”</strong> 或者 <strong>“开启隐私保护”</strong> 的勾选框。</li>
<li>腾讯云现在大部分后缀是默认免费赠送并开启的，确认一下即可。这能防止你的手机号被公开查到。</li>
</ul>
</li>
<li><p><strong>支付</strong>：</p>
<ul>
<li>确认金额（我买的时候 .com 首年 83 元左右），然后直接使用微信支付即可。</li>
</ul>
</li>
<li><p><strong>验证隐私保护设置是否开启成功（保护隐私比较重要）</strong></p>
<ul>
<li>购买成功后，可以打开 whois.cloud.tencent.com (或者直接百度搜 “whois查询”)。</li>
<li>输入你的域名。</li>
<li>看查询结果里的 “注册人&#x2F;Registrant”。</li>
<li>如果显示的是你的真名 -&gt; 没开成功。</li>
<li>如果显示的是 “通过表单联系域名所有者” 这种乱七八糟的代码 -&gt; 开成功了。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="（3）配置解析（让域名指向你的博客）"><a href="#（3）配置解析（让域名指向你的博客）" class="headerlink" title="（3）配置解析（让域名指向你的博客）"></a>（3）配置解析（让域名指向你的博客）</h4><p>搞定域名后告一段落！<br>但如果现在要访问 <a href="http://catistrue.com/">http://catistrue.com/</a> 会发现还是打不开。</p>
<p>这是完全正常的！别慌。</p>
<p>买完域名到能正常访问，中间缺了最关键的<strong>搭桥</strong>环节。</p>
<p>我们在腾讯云买了 <code>catistrue.com</code>，这就像刚领了个<strong>车牌号</strong>。但是：</p>
<ol>
<li>你还没把这个车牌号挂在你的<strong>车子</strong>（Vercel 或 GitHub）上。</li>
<li>即使挂上了，送信的邮递员（DNS服务器）还没来得及更新地图。</li>
</ol>
<p>现在的空白，说明这个域名<strong>还不知道该去哪里</strong>。</p>
<p>在解决这个问题前，先插播一段：我需要配置<code>Vercel</code></p>
<p>因为我不想在接下来换电脑的时候反复配环境，我的预期是新的电脑只写文章 (CI&#x2F;CD 自动化)利用 GitHub Actions，把“生成网页”这个苦力活交给 GitHub 的服务器去做。并且希望 <strong>国内外都能访问</strong>，所以我最后采用 <strong>“GitHub 存储代码 + Vercel 自动构建&#x2F;托管”</strong> 的组合。</p>
<p><strong>为什么要这样组合？</strong></p>
<ul>
<li><strong>GitHub Pages</strong>：在国内访问经常抽风，有时候慢到打不开。</li>
<li><strong>Vercel</strong>：它自带了全球 CDN（包括针对大陆地区的优化线路），速度比 GitHub Pages 快得多，而且极其稳定。</li>
<li><strong>自动化</strong>：Vercel 会自动监听你的 GitHub 仓库。你只要往 GitHub 传了 <code>.md</code> 文件，Vercel 就会立刻感知到，自动在云端帮你执行 <code>hexo g</code> 生成网页并发布。<strong>你连 GitHub Actions 脚本都不用写！</strong></li>
</ul>
<hr>
<p>下面是全流程的操作步骤</p>
<h5 id="第一步：在-Vercel-上“认领”你的代码"><a href="#第一步：在-Vercel-上“认领”你的代码" class="headerlink" title="第一步：在 Vercel 上“认领”你的代码"></a>第一步：在 Vercel 上“认领”你的代码</h5><ol>
<li>去 <a href="https://vercel.com/">Vercel 官网</a> 注册一个账号（直接用 GitHub 账号登录）。</li>
<li>登录后，点击 <strong>“Add New…”</strong> -&gt; **”Project”**。</li>
<li>它会列出你 GitHub 里的仓库，找到你的 <strong>Hexo 博客仓库</strong>，点击 <strong>Import</strong>。</li>
<li><strong>关键配置（Vercel 足够聪明，通常会自动填好）：</strong><ul>
<li><strong>Framework Preset</strong>: 选 <code>Hexo</code>。</li>
<li><strong>Build Command</strong>: <code>hexo generate</code> (或者 <code>hexo g</code>)。</li>
<li><strong>Output Directory</strong>: <code>public</code>。</li>
<li>点击 <strong>Deploy</strong>。</li>
</ul>
</li>
</ol>
<p>等几十秒，你会看到满屏庆祝的彩带，说明 Vercel 已经成功把你的博客在云端构建出来了！</p>
<h5 id="第二步：在-Vercel-端设置（让国内外都能访问）"><a href="#第二步：在-Vercel-端设置（让国内外都能访问）" class="headerlink" title="第二步：在 Vercel 端设置（让国内外都能访问）"></a>第二步：在 Vercel 端设置（让国内外都能访问）</h5><p>这一步就是把刚才我们在腾讯云买的域名，指引到 Vercel 上。</p>
<ol>
<li><p><strong>在 Vercel 端设置</strong>：<br>进入你刚才创建的项目 -&gt; <strong>Settings</strong> -&gt; <strong>Domains</strong>。</p>
</li>
<li><p><strong>输入框</strong>：<br>填好 <code>catistrue.com</code> （刚才在腾讯云注册的域名）</p>
</li>
<li><p>**Redirect catistrue.com to <a href="http://www.catistrue.com/">www.catistrue.com</a> (Recommended)**：<br><strong>务必勾选（默认已经勾选了）！</strong></p>
<ul>
<li><strong>为什么要勾选？</strong><br>这是 Vercel 的一个最佳实践。它会自动帮你配置两个域名：<code>catistrue.com</code> (根域名) 和 <code>www.catistrue.com</code> (带www的域名)。<br>勾选后，当别人访问 <code>catistrue.com</code> 时，会自动跳转到 <code>www.catistrue.com</code>。这对 SEO（搜索引擎优化）和 CDN 缓存都更友好。如果不勾选，两个域名是独立的，虽然也能访问，但不够规范。</li>
</ul>
</li>
</ol>
<p><strong>接着直接点击右下角的黑底白字按钮 “Add” (或者 “Save”) 即可！</strong></p>
<p>点完之后，它会跳回原来的界面，并显示两个红色的或者黄色的提示（Invalid Configuration），这是正常的，因为你还没去腾讯云（DNSPod）那边改解析记录。（戳开这俩提示，可以看到对应的<code>@</code>、<code>www</code>信息，后续要用）</p>
<h5 id="第三步：在腾讯云（DNSPod）端设置（最关键的一步）"><a href="#第三步：在腾讯云（DNSPod）端设置（最关键的一步）" class="headerlink" title="第三步：在腾讯云（DNSPod）端设置（最关键的一步）"></a>第三步：在腾讯云（DNSPod）端设置（最关键的一步）</h5><p><strong>回到腾讯云</strong></p>
<ul>
<li>回到腾讯云控制台 -&gt; <strong>DNS 解析 DNSPod</strong>。</li>
<li>点击你的域名，添加（或修改）以下两条记录：</li>
</ul>
<p>请务必<strong>完全按照</strong> Vercel提供的信息填写，不要自己发挥：</p>
<p><strong>第一条记录：给根域名 <code>catistrue.com</code> 用的</strong></p>
<ul>
<li><strong>主机记录</strong>：<code>@</code></li>
<li><strong>记录类型</strong>：<code>A</code></li>
<li><strong>记录值</strong>：<code>xx.xx.xx.xx</code> (以 Vercel 显示的为准)</li>
</ul>
<p><strong>第二条记录：给 <code>www</code> 子域名用的</strong></p>
<ul>
<li><strong>主机记录</strong>：<code>www</code></li>
<li><strong>记录类型</strong>：<code>CNAME</code></li>
<li><strong>记录值</strong>：<code>xxx.com</code> (以 Vercel 显示的为准)</li>
</ul>
<hr>
<p>操作完毕后<br>回到 Vercel 这个界面，等待几分钟（有时候秒级生效，有时候要等10分钟）。</p>
<p>那个红色的 <strong>Invalid Configuration</strong> 会自动变成蓝色的 <strong>Valid</strong> 或者对勾。<br><img src="/images/image-3.png" alt="配置完成"></p>
<h5 id="第四步：给-Hexo-本地加个保险（可选但推荐）"><a href="#第四步：给-Hexo-本地加个保险（可选但推荐）" class="headerlink" title="第四步：给 Hexo 本地加个保险（可选但推荐）"></a>第四步：给 Hexo 本地加个保险（可选但推荐）</h5><p>为了防止 Hexo 在生成的时候不知道自己的域名变了，建议修改你本地博客的配置文件。</p>
<ol>
<li>打开你电脑上博客根目录下的 <code>_config.yml</code> 文件。</li>
<li>找到 <code>url:</code> 这一行。</li>
<li>改成：<code>url: https://catistrue.com</code></li>
<li>把这个修改推送到 GitHub。</li>
</ol>
<hr>
<p>激动人心的时刻来了，现在，打开电脑，除了可以访问<code>https://catistrue.github.io/</code> ,还可以访问<code>https://catistrue.com</code> , <code>https://www.catistrue.com</code>。<br>个人博客网站可以打开啦！（太棒了！🎉 恭喜我们！）</p>
<p><strong>ps</strong><br>如果到这一步还是能打开个人网站，不用担心，现在打不开，只剩下一个原因：SSL 证书还没颁发好，或者本地 DNS 缓存没更新。可以再等一会儿，或者在终端输入<code>ipconfig /flushdns</code>刷新一下DNS解析缓存看看。</p>
<hr>
<h3 id="第五阶段：日常使用流程"><a href="#第五阶段：日常使用流程" class="headerlink" title="第五阶段：日常使用流程"></a>第五阶段：日常使用流程</h3><p>恭喜！我们已经完成全部的搭建过程了。</p>
<ol>
<li><p><strong>以后的工作流</strong>：</p>
<ul>
<li>在任何电脑上写好 <code>xxx.md</code> 文章。</li>
<li>扔进 <code>source/_posts</code> 文件夹。</li>
<li>通过 Git 推送到 GitHub。</li>
<li><strong>结束！</strong> Vercel 会自动构建，两分钟后我的域名 <code>catistrue.com</code> 上就有新文章了。</li>
</ul>
</li>
<li><p><strong>访问体验</strong>：</p>
<ul>
<li><strong>国外用户</strong>：飞快，直接连 Vercel 的海外节点。</li>
<li><strong>国内用户</strong>：比较快，走 Vercel 优化的亚洲节点（通常是香港或新加坡），比直连 GitHub 快10倍以上。</li>
</ul>
</li>
</ol>
<hr>
<p>如果你也想拥有一个酷炫的独立博客，希望这篇教程能帮到你。</p>
]]></content>
      <categories>
        <category>技术折腾</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Hexo</tag>
        <tag>博客搭建</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>ifconfig指令配置网卡信息</title>
    <url>/posts/e0d0b007.html</url>
    <content><![CDATA[<h1 id="ifconfig指令配置网卡信息"><a href="#ifconfig指令配置网卡信息" class="headerlink" title="ifconfig指令配置网卡信息"></a>ifconfig指令配置网卡信息</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>linux&#x2F;unix系统下，输入ifconfig指令，发现只有lo本地回环，没有网卡信息，为了能够正常上网，需要配置一下网卡信息</p>
<p>当输入指令</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span></span><br><span class="line">(可以自行设置ip地址）</span><br></pre></td></tr></table></figure>

<p>会提示报错信息</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">SIOCSIFADDR</span>: <span class="title class_">No</span> such device</span><br><span class="line"><span class="attr">eth0</span>: <span class="variable constant_">ERROR</span> <span class="keyword">while</span> getting interface <span class="attr">flags</span>: <span class="title class_">No</span> such device</span><br></pre></td></tr></table></figure>

<p>此时，我们会发现设置网卡eth0失败了，提示我们没有这个网卡。那么，很有可能，我们的网卡不叫“eth0”这个名字，而不是我们真的没有网卡。</p>
<h2 id="ifconfig-a"><a href="#ifconfig-a" class="headerlink" title="ifconfig -a"></a>ifconfig -a</h2><p>输入指令</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ifconfig -a</span><br></pre></td></tr></table></figure>

<p>此时，我们可以看到系统列出来我们所有的网卡名，如下图：</p>
<p><img src="/images/ifconfig-a.jpg" alt="ifconfig-a指令显示所有网卡"></p>
<h2 id="配置网卡的ip"><a href="#配置网卡的ip" class="headerlink" title="配置网卡的ip"></a>配置网卡的ip</h2><p>接下来，我们发现自己系统的网卡果然没有eth0这个网卡名，但是有en0，所以，接下来我们设置来配置这个网卡的ip</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ifconfig en0 <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span></span><br><span class="line">(可以自行设置ip地址）</span><br></pre></td></tr></table></figure>
<p>然后回车后，就发现设置ip成功啦～</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般情况下，因为我们常见的linux下的网卡名字都是eth0，所以习惯性的就直接配置eth0的ip，但是有的系统并不是用eth0当网卡名，所以还是要先输入ifconfig -a指令，来查看一下我们当前的系统下，网卡的名字都是什么，然后再去配置ip</p>
]]></content>
      <categories>
        <category>技术折腾</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>配置网卡</tag>
      </tags>
  </entry>
  <entry>
    <title>libcryptopp源码编译</title>
    <url>/posts/c428b79b.html</url>
    <content><![CDATA[<h1 id="libcryptopp源码编译"><a href="#libcryptopp源码编译" class="headerlink" title="libcryptopp源码编译"></a>libcryptopp源码编译</h1><h2 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h2><p>1.下载源码，解压<br>2.修改GNUmakefile<br>因为是64位编译32位的库，还增加了-m32选项</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable constant_">CXXFLAGS</span> += -pipe -fPIC</span><br><span class="line"><span class="variable constant_">CXXFLAGS</span> += -m32</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如下图：<br><img src="/images/cryptopp_complie.jpg" alt="cryptopp_complie"></p>
<p>3.然后make</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">make libcryptopp.<span class="property">a</span> libcryptopp.<span class="property">so</span> cryptest</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/cryptopp_complie_2.jpg" alt="cryptopp_complie_2"></p>
<p>4.然后安装make install</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">可以指定安装路径，如不想安装到默认路径</span><br><span class="line">make install <span class="variable constant_">PREFIX</span>=<span class="regexp">/usr/</span>local/selfpath</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/cryptopp_complie_3.jpg" alt="cryptopp_complie_3"></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.lwlwq.com/post-cryptopp.html">https://www.lwlwq.com/post-cryptopp.html</a></p>
]]></content>
      <categories>
        <category>交叉编译</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>交叉编译</tag>
        <tag>libcryptopp</tag>
      </tags>
  </entry>
  <entry>
    <title>libcurl交叉编译</title>
    <url>/posts/ad4da72c.html</url>
    <content><![CDATA[<h1 id="libcurl交叉编译"><a href="#libcurl交叉编译" class="headerlink" title="libcurl交叉编译"></a>libcurl交叉编译</h1><h1 id="需要源码交叉编译libcurl操作步骤"><a href="#需要源码交叉编译libcurl操作步骤" class="headerlink" title="需要源码交叉编译libcurl操作步骤"></a>需要源码交叉编译libcurl操作步骤</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>有时候需要交叉编译libcurl，比如目标机器是32位系统的，但是本地机器是64位系统的，而且由于某些原因，我们无法在32位系统上直接编译，所以需要用到交叉编译</p>
<h2 id="编译openssl"><a href="#编译openssl" class="headerlink" title="编译openssl"></a>编译openssl</h2><p>libcurl是依赖openssl的，所以先编译openssl的32位库</p>
<p>完整编译选项配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setarch i386 ./config -m32 –prefix=/home/muhan/openssl/ –openssldir=/home/muhan/openssl/ -Wl,-rpath,/usr/local/openssl/lib shared</span><br></pre></td></tr></table></figure>
<p>详细选项含义如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">配置-m32 指定编译32位的库</span><br><span class="line">配置–prefix 指定openssl的安装目录</span><br><span class="line">配置–openssldir 指定openssl的头文件目录</span><br><span class="line">配置shared关键字 指定编译时生成动态库（libssl.so/libcrypto.so及其相关软连接）</span><br></pre></td></tr></table></figure>

<p>然后再make &amp;&amp; make install 即可</p>
<h2 id="编译安装zlib"><a href="#编译安装zlib" class="headerlink" title="编译安装zlib"></a>编译安装zlib</h2><p>有时候有的系统是默认安装了32位zlib库的，那么就可以跳过这一步，但是有的系统需要自己下载编译zlib-32位库</p>
<p>完整编译选项配置如下：<br>直接修改CMakeLists.txt文件，增加以下两行</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_C_FLAGS “-m32”)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS “-m32”)</span><br></pre></td></tr></table></figure>
<p>详细选项含义如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">配置CMAKE_C_FLAGS 指定编译32位库环境</span><br><span class="line">配置CMAKE_CXX_FLAGS 指定编译32位库环境</span><br></pre></td></tr></table></figure>

<p>然后再mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make &amp;&amp; make install 即可</p>
<h2 id="编译安装libcurl"><a href="#编译安装libcurl" class="headerlink" title="编译安装libcurl"></a>编译安装libcurl</h2><p>最后就是编译libcurl</p>
<p>完整编译选项配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure PKG_CONFIG_PATH=/home/muhan/openssl CFLAGS=”-m32” CPPFLAGS=”-I/home/muhan/openssl/include” LDFLAGS=”-L/home/muhan/openssl/lib”</span><br></pre></td></tr></table></figure>

<p>详细选项含义如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">配置PKG_CONFIG_PATH 指定启动openssl选项(启动这个选项，就会默认链接lssl，lcrypto，lz三个库)</span><br><span class="line">配置CFLAGS 指定编译32位库环境</span><br><span class="line">配置CPPFLAGS 指定链接的库的头文件</span><br><span class="line">配置LDFLAGS 指定链接的库的路径</span><br></pre></td></tr></table></figure>

<p>然后再make &amp;&amp; make install 即可</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当编译第三方库的时候，如果有CMakeLists.txt，直接用CMakeLists.txt编译就很方便；<br>如果只有configure，那么需要先了解编译选项</p>
<p>执行.&#x2F;configure –help 来查看当前支持的编译选项<br>然后根据提示配置一下我们需要指定的选项，比如自己指定的openssl的版本的库和头文件路径名，比如CC的版本，比如安装路径等等<br>(当然，如果不需要额外配置这些东西的话，直接走默认配置的话，那么直接执行.&#x2F;config 或者 .&#x2F;configure 就行)</p>
<p>然后在生成Makefile之后，再make &amp;&amp; make install 即可</p>
]]></content>
      <categories>
        <category>交叉编译</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>交叉编译</tag>
        <tag>libcurl</tag>
      </tags>
  </entry>
  <entry>
    <title>linux项目移植到Windows下CMake改造</title>
    <url>/posts/fe7b4b0a.html</url>
    <content><![CDATA[<h1 id="linux项目移植到Windows下CMake改造"><a href="#linux项目移植到Windows下CMake改造" class="headerlink" title="linux项目移植到Windows下CMake改造"></a>linux项目移植到Windows下CMake改造</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>因项目工程需要，将linux下的<code>AProject</code>项目迁移到Windows下，对代码进行适配，编译选项进行修改。<br>通过CMake配置Windows(MSVC编译器)选项，进行跨平台移植。</p>
<h2 id="Windows下工具链"><a href="#Windows下工具链" class="headerlink" title="Windows下工具链"></a>Windows下工具链</h2><p>CMake+Visual Studio 2022</p>
<h2 id="CMake调整关键点"><a href="#CMake调整关键点" class="headerlink" title="CMake调整关键点"></a>CMake调整关键点</h2><p>关键片段</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(MSVC)</span><br><span class="line">  <span class="keyword">option</span>(BUILD_SHARED_LIBS <span class="string">&quot;Build shared libraries (.dll).&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line">  <span class="keyword">add_compile_definitions</span>(_USE_MATH_DEFINES)</span><br><span class="line">  <span class="keyword">add_compile_definitions</span>(NOMINMAX)</span><br><span class="line">  <span class="keyword">string</span>(APPEND CMAKE_CXX_FLAGS <span class="string">&quot; /diagnostics:classic /utf-8 /MP /bigobj /EHsc /W3&quot;</span>)</span><br><span class="line">  <span class="keyword">string</span>(APPEND CMAKE_C_FLAGS   <span class="string">&quot; /diagnostics:classic /utf-8 /MP /bigobj /W3&quot;</span>)</span><br><span class="line">  <span class="keyword">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="string">&quot;$&#123;CMAKE_EXE_LINKER_FLAGS&#125; /STACK:10000000&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span>(MSVC_VERSION <span class="keyword">GREATER_EQUAL</span> <span class="number">1914</span>)</span><br><span class="line">    <span class="keyword">add_compile_options</span>(/Zc:__cplusplus)</span><br><span class="line">  <span class="keyword">endif</span>() </span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>这段 CMake 配置代码是专门为 <strong>Windows (MSVC 编译器)</strong> 准备的“大补丁包”。</p>
<p>它的主要目的是：<strong>让 Visual Studio 的行为更像 Linux 下的 GCC&#x2F;Clang，同时解决 Windows 特有的一些“坑”。</strong></p>
<p>下面逐条详细解释：</p>
<h3 id="1-库的构建方式"><a href="#1-库的构建方式" class="headerlink" title="1. 库的构建方式"></a>1. 库的构建方式</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">option</span>(BUILD_SHARED_LIBS <span class="string">&quot;Build shared libraries (.dll).&quot;</span> <span class="keyword">OFF</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>含义</strong>：定义一个开关，默认设置为 <code>OFF</code>。</li>
<li><strong>作用</strong>：告诉 CMake 默认编译 <strong>静态库 (.lib)</strong> 而不是 **动态库 (.dll)**。</li>
<li><strong>场景</strong>：如果你不想在运行 exe 时拖着一堆 <code>.dll</code> 文件到处跑，或者不想处理复杂的 dll 导出符号（<code>__declspec(dllexport)</code>），用静态库是最省事的。</li>
</ul>
<h3 id="2-预处理器定义-Preprocessor-Definitions"><a href="#2-预处理器定义-Preprocessor-Definitions" class="headerlink" title="2. 预处理器定义 (Preprocessor Definitions)"></a>2. 预处理器定义 (Preprocessor Definitions)</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_compile_definitions</span>(_USE_MATH_DEFINES)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>含义</strong>：开启数学常量定义。</li>
<li><strong>为什么需要</strong>：标准 C++ 其实不强制要求提供 <code>M_PI</code> (圆周率) 这种宏。Linux 的 math.h 默认有，但 Windows 为了严格符合标准默认把它藏起来了。</li>
<li><strong>效果</strong>：加上它，你才能在代码里愉快地使用 <code>M_PI</code>、<code>M_PI_2</code> 等宏，否则会报错“未声明的标识符”。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_compile_definitions</span>(NOMINMAX)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>含义</strong>：<strong>这是一个救命的宏。</strong> 禁用 Windows 头文件中的 <code>min</code> 和 <code>max</code> 宏。</li>
<li><strong>为什么需要</strong>：Windows 的 <code>&lt;windows.h&gt;</code> 历史遗留问题，它定义了全局宏 <code>min(a,b)</code> 和 <code>max(a,b)</code>。这会严重干扰 C++ 标准库的 <code>std::min</code> 和 <code>std::max</code>。</li>
<li><strong>效果</strong>：如果不加这个，当你写 <code>std::max(1, 2)</code> 时，预处理器会把它替换成错误的乱码从而编译失败。</li>
</ul>
<h3 id="3-编译器标志-Compile-Flags"><a href="#3-编译器标志-Compile-Flags" class="headerlink" title="3. 编译器标志 (Compile Flags)"></a>3. 编译器标志 (Compile Flags)</h3><p>这些标志被追加到了 <code>CMAKE_CXX_FLAGS</code> (C++) 和 <code>CMAKE_C_FLAGS</code> (C) 中。</p>
<ul>
<li><p><strong><code>/diagnostics:classic</code></strong></p>
<ul>
<li><strong>含义</strong>：设置报错信息的格式为经典模式。</li>
<li><strong>作用</strong>：VS2022 新版有时候报错信息太花哨，而且有时候VS界面读不懂编译器输出把真正的编译错误给吞掉（如<code>MSB8084</code>“CL.exe”的结构化输出无效: 无法分析 JsonRpc 通知:“Cannot transcode invalid UTF-8 JSON text to UTF-16 string.”这种报错。），用这个可以让输出格式变回 <code>文件名(行号): error ...</code>，更清晰。</li>
</ul>
</li>
<li><p><strong><code>/utf-8</code></strong></p>
<ul>
<li><strong>含义</strong>：<strong>强制源文件和执行字符集都为 UTF-8。</strong></li>
<li><strong>作用</strong>：<strong>极其重要</strong>。Linux 代码通常是 UTF-8 的，而 Windows 中文环境默认是 GBK。</li>
<li><strong>场景</strong>：如果不加这个，你的代码里如果有中文字符串（比如 <code>printf(&quot;你好&quot;)</code>），打印出来就是乱码；或者代码里有中文注释，可能会导致编译报错。</li>
</ul>
</li>
<li><p><strong><code>/MP</code></strong></p>
<ul>
<li><strong>含义</strong>：<strong>多进程编译 (Multi-Processor)。</strong></li>
<li><strong>作用</strong>：<strong>加速神器</strong>。它允许 VS 同时启动多个编译器进程来编译不同的源文件，利用多核 CPU。不加这个，编译速度会慢很多。</li>
</ul>
</li>
<li><p><strong><code>/bigobj</code></strong></p>
<ul>
<li><strong>含义</strong>：允许生成更大的对象文件（增加节的数量限制）。</li>
<li><strong>作用</strong>：**防止 <code>fatal error C1128</code>**。</li>
<li><strong>场景</strong>：如果你的代码里大量使用了模板（Template）、或者某个 <code>.cpp</code> 文件特别巨大（几万行），生成的 <code>.obj</code> 文件会超过默认限制。加上它就能解决。</li>
</ul>
</li>
<li><p><strong><code>/EHsc</code></strong> (仅 C++)</p>
<ul>
<li><strong>含义</strong>：启用标准 C++ 异常处理模型。</li>
<li><strong>作用</strong>：告诉编译器捕捉 C++ 的 <code>try-catch</code> 异常，并假设 <code>extern &quot;C&quot;</code> 的函数不会抛出异常。这是 VS 编译 C++ 代码的标准姿势。</li>
</ul>
</li>
<li><p><strong><code>/W3</code></strong></p>
<ul>
<li><strong>含义</strong>：警告等级 3 (Warning Level 3)。</li>
<li><strong>作用</strong>：开启大部分常用的警告。等级从 <code>/W0</code> (不警告) 到 <code>/W4</code> (极度严格)。<code>/W3</code> 是一个比较平衡的生产环境选择。</li>
</ul>
</li>
</ul>
<h3 id="4-链接器标志-Linker-Flags"><a href="#4-链接器标志-Linker-Flags" class="headerlink" title="4. 链接器标志 (Linker Flags)"></a>4. 链接器标志 (Linker Flags)</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="string">&quot;$&#123;CMAKE_EXE_LINKER_FLAGS&#125; /STACK:10000000&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>含义</strong>：设置主线程栈大小为 ~10MB。</li>
<li><strong>作用</strong>：防止栈溢出（Stack Overflow）。<br>详细讨论可以看另一篇博客：<br><a href="cmake%E9%80%89%E9%A1%B9%E4%B9%8BCMAKE_EXE_LINKER_FLAGS.md">增大函数栈内存空间</a></li>
</ul>
<h3 id="5-语言标准修正"><a href="#5-语言标准修正" class="headerlink" title="5. 语言标准修正"></a>5. 语言标准修正</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(MSVC_VERSION <span class="keyword">GREATER_EQUAL</span> <span class="number">1914</span>)</span><br><span class="line">    <span class="keyword">add_compile_options</span>(/Zc:__cplusplus)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>含义</strong>：如果 MSVC 版本大于等于 1914 (VS 2017 15.7)，则启用 <code>/Zc:__cplusplus</code>。</li>
<li><strong>为什么需要</strong>：这是一个历史坑。默认情况下，即使你开启了 C++17 或 C++20，MSVC 里的 <code>__cplusplus</code> 宏的值依然是 <code>199711L</code>（老标准）。这会导致很多跨平台库（如 Boost, Qt）误以为编译器不支持新特性。</li>
<li><strong>效果</strong>：加上这个后，<code>__cplusplus</code> 宏就会正确报告版本号（如 C++17 会报告 <code>201703L</code>），让代码能正确识别当前的语言标准。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这份配置可以解决很多<strong>项目代码无关平台特性强相关</strong>的报错，它<strong>把 Visual Studio 调教得更符合现代 C++ 标准和跨平台开发习惯</strong>。<br>如果不加这些配置，直接把 Linux 代码拿过来编译，通常会遇到中文乱码、数学库报错、min&#x2F;max 冲突等一堆琐碎问题。。。</p>
]]></content>
      <categories>
        <category>技术折腾</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>windows</tag>
        <tag>linux</tag>
        <tag>CMake</tag>
        <tag>跨平台移植</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下查看编译的静态库和动态库是32位还是64位</title>
    <url>/posts/4a576f58.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>有时候可能会需要交叉编译，所以需要知道平台上编译出来的版本到底是64位还是32位</p>
<h2 id="file指令查看动态库是32位还是64位"><a href="#file指令查看动态库是32位还是64位" class="headerlink" title="file指令查看动态库是32位还是64位"></a>file指令查看动态库是32位还是64位</h2><p>如图：file libcurl.so 查看当前编译的libcurl.so是32位还是64位的<br><img src="/images/file_so.jpg" alt="file_so.jpg"></p>
<h2 id="objdump-a指令查看静态库是32位还是64位的"><a href="#objdump-a指令查看静态库是32位还是64位的" class="headerlink" title="objdump -a指令查看静态库是32位还是64位的"></a>objdump -a指令查看静态库是32位还是64位的</h2><p>如图：objdump -a libtest.a 查看当前编译的静态库libtest.a是32位还是64位的<br><img src="/images/objdump_a.jpg" alt="objdupm_a.jpg"></p>
<h2 id="readelf-h指令查看静态库or动态库是32位or64位，及编译平台运行平台等信息"><a href="#readelf-h指令查看静态库or动态库是32位or64位，及编译平台运行平台等信息" class="headerlink" title="readelf -h指令查看静态库or动态库是32位or64位，及编译平台运行平台等信息"></a>readelf -h指令查看静态库or动态库是32位or64位，及编译平台运行平台等信息</h2><p>如图：readelf -h libssl.so 查看编译的动态库lib<br>Class字段显示当前库是32位or64位<br>Machine字段显示当前库运行的目标机器系统</p>
<p><img src="/images/readelf_h.jpg" alt="readelf_h.jpg"></p>
]]></content>
      <categories>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>交叉编译</tag>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title>linux插件系统加载器-使用dl库</title>
    <url>/posts/3ba077d3.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在 C&#x2F;C++ 开发中，项目里需要在程序运行期间加载一个外部的代码库（而不是在编译时链接），而且根据不同的配置，需要加载不同的代码库，进行热更新，那直接考虑的就是插件架构。</p>
<p>操作系统提供的原生 API 是完全不同的，如果是在linux下，使用libdl库。一般使用这个库就是为了做插件系统加载器（可以说是它最主要的用途了）。</p>
<h2 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">short</span> <span class="title">loadLibDemo::realLoadLib</span><span class="params">(<span class="type">const</span> string&amp; libPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(libPath.<span class="built_in">length</span>() &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	libHandle = <span class="built_in">dlopen</span>(libPath.<span class="built_in">c_str</span>(), RTLD_GLOBAL | RTLD_NOW);</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span>==libHandle)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;dlopen fail %s\n&quot;</span>,<span class="built_in">dlerror</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pOne = (PFUN_APIOne)<span class="built_in">dlsym</span>(libHandle, <span class="string">&quot;one_fun_api&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == pOne)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[PFUN_APIOne] dlsym fail %s\n&quot;</span>,<span class="built_in">dlerror</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pTwo = (PFUN_APITwo)<span class="built_in">dlsym</span>(libHandle, <span class="string">&quot;two_fun_api&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == pTwo)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[PFUN_APITwo] dlsym fail %s\n&quot;</span>,<span class="built_in">dlerror</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pThree = (PFUN_APIThree)<span class="built_in">dlsym</span>(libHandle, <span class="string">&quot;three_fun_api&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == pThree)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[PFUN_APIThree] dlsym fail %s\n&quot;</span>,<span class="built_in">dlerror</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pFour = (PFUN_APIFour)<span class="built_in">dlsym</span>(libHandle, <span class="string">&quot;four_fun_api&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == pFour)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[PFUN_APIFour] dlsym fail %s\n&quot;</span>,<span class="built_in">dlerror</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pFive = (PFUN_APIFive)<span class="built_in">dlsym</span>(libHandle, <span class="string">&quot;five_fun_api&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == pFive)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[PFUN_APIFive] dlsym fail %s\n&quot;</span>,<span class="built_in">dlerror</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pSix = (PFUN_APISix)<span class="built_in">dlsym</span>(libHandle, <span class="string">&quot;six_fun_api&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == pSix)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[PFUN_APISix] dlsym fail %s\n&quot;</span>,<span class="built_in">dlerror</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码已经放在了<a href="https://github.com/TreeAndFlower/loadlibdemo-linux">https://github.com/TreeAndFlower/loadlibdemo-linux</a></p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>主要是，要对导出的动态库里的API，记得“extern c”</p>
<p>当没有extern c的时候，编译出来的动态库里API如下：</p>
<p><img src="/images/wu_extern_c.jpg" alt="默认是g++编译，所以有前缀后缀"></p>
<p>当extern c添加了以后，编译出来的动态库API如下：</p>
<p><img src="/images/you_extern_c.jpg" alt="相当于选择了gcc编译，没有多余的Z11前缀v后缀等内容"></p>
<p>PS:</p>
<p>这个示例代码，仅在linux平台下生效，因为链接的<code>dl</code>库，头文件是<code>#include &lt;dlfcn.h&gt;</code>，这些是linux平台的；<br>windows下用<code>Kernel32.lib</code>库，头文件是<code>Windows.h</code>；</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下安装tcpdump并用其抓包</title>
    <url>/posts/12907b44.html</url>
    <content><![CDATA[<h1 id="linux下安装tcpdump并用其抓包"><a href="#linux下安装tcpdump并用其抓包" class="headerlink" title="linux下安装tcpdump并用其抓包"></a>linux下安装tcpdump并用其抓包</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>有时候需要分析网络协议，这时候抓包看看直接的数据，能够有助于对协议有一个直观的感受，在windows下，可以直接安装Wireshark就能轻松抓包分析了，但是在linux下，没有Wireshark，所以可以安装tcpdump，用tcpdump抓包分析</p>
<h2 id="安装tcpdump"><a href="#安装tcpdump" class="headerlink" title="安装tcpdump"></a>安装tcpdump</h2><p>安装tcpdump有两种方式，一种是下载tcpdump源码，然后编译安装；另一种是直接用系统安装命令</p>
<h3 id="下载源码安装tcpdump"><a href="#下载源码安装tcpdump" class="headerlink" title="下载源码安装tcpdump"></a>下载源码安装tcpdump</h3><p>这个可以参考：<a href="https://blog.csdn.net/tic_yx/article/details/17012317">https://blog.csdn.net/tic_yx/article/details/17012317</a><br>这篇文章里记录的很详细<br>文章内容截图如下：<br><img src="/images/complie_tcpdump.jpg" alt="源码编译tcpdump"></p>
<h3 id="直接用系统安装命令"><a href="#直接用系统安装命令" class="headerlink" title="直接用系统安装命令"></a>直接用系统安装命令</h3><p>在ubuntu下，可以直接使用sudo apt-get install tcpdump<br>如果这一步安装的时候有报错，可以更新一下下载源，国内清华的下载源还是很好用的</p>
<h2 id="用tcpdump抓包"><a href="#用tcpdump抓包" class="headerlink" title="用tcpdump抓包"></a>用tcpdump抓包</h2><p>sudo tcpdump -i 网卡 -entXX<br><img src="/images/use_tcpdump.jpg" alt="使用tcpdump抓包"></p>
<p>也可以把tcpdump抓到的数据保存到文件里<br>sudo tcpdump -i 网卡 -entXX -w 文件名.pcap<br><img src="/images/tcpdump_save_file.jpg" alt="tcpdump抓包后保存到文件里"><br>然后将pcap文件从linux里拷贝到windows下，用Wireshark分析数据</p>
]]></content>
      <categories>
        <category>技术折腾</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>tcpdump</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>将linux下源码文件，直接放在windows下vs编译的时候，关于undeclared identifier的奇怪报错</title>
    <url>/posts/12cd23b6.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我的一个工程里的源文件就叫他a.cpp,在linux下可以正常的编译，由于工程需要移植到windos下，所以我把a.cpp源文件移动到windows下的工程里，然后编译，编译的时候，发现有两个特别诡异的报错，报错内容如下：</p>
<p><img src="/images/copy_cpp_error.jpg" alt="直接将cpp从Linux下挪到windows下报错"></p>
<p>更为奇怪的是，如果我在windows操作系统下，将a.cpp文件，用sublime.txt打开，然后再全选内容，拷贝到vs到工程里报错的a.cpp文件里，然后发现可以成功编译！</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>经过一系列脑壳疼的排查，最终发现，这是因为，linux下和windows下的换行符不一样！！！<br>如果用sublime.txt把报错的源文件a.cpp的所有\n替换成windows下的\r\n,然后再保存文件，把保存修改的文件，挪到vs里直接编译，发现阔以了！！！</p>
<p>vs是不支持把linux下的换行符主动转成windows下的换行符的！！！巨坑</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>后来，查看了网友将linux和windows换行符的区别，讲的特别好<br>链接：<a href="https://blog.csdn.net/stpeace/article/details/45767245">https://blog.csdn.net/stpeace/article/details/45767245</a></p>
<p>讲解的特别精彩的截图片段<br><img src="/images/huanhangfu.jpg" alt="linux与windows换行符的区别"></p>
<h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>不得不说，像换行符这种巨坑的问题，排查起来简直特别特别坑……</p>
]]></content>
      <categories>
        <category>跨平台移植</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>linux</tag>
        <tag>跨平台移植</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机安装官方树莓派系统，配置交叉编译链</title>
    <url>/posts/71c1cc71.html</url>
    <content><![CDATA[<h1 id="虚拟机安装官方树莓派系统，配置交叉编译链"><a href="#虚拟机安装官方树莓派系统，配置交叉编译链" class="headerlink" title="虚拟机安装官方树莓派系统，配置交叉编译链"></a>虚拟机安装官方树莓派系统，配置交叉编译链</h1><h2 id="1-下载官方镜像"><a href="#1-下载官方镜像" class="headerlink" title="1.下载官方镜像"></a>1.下载官方镜像</h2><p><a href="https://www.raspberrypi.org/software/raspberry-pi-desktop/">https://www.raspberrypi.org/software/raspberry-pi-desktop/</a><br>通过官网，下载raspberry镜像64位系统iso文件之后，可以安装在虚拟机vbox&#x2F;vmware里</p>
<h2 id="2-下载交叉编译工具链"><a href="#2-下载交叉编译工具链" class="headerlink" title="2.下载交叉编译工具链"></a>2.下载交叉编译工具链</h2><p>通过github下载最新的官方树莓派交叉编译工具链<br>git clone git:&#x2F;&#x2F;github.com&#x2F;raspberrypi&#x2F;tools.git</p>
<h2 id="3-配置交叉编译工具链"><a href="#3-配置交叉编译工具链" class="headerlink" title="3.配置交叉编译工具链"></a>3.配置交叉编译工具链</h2><p>将arm-bcm2708文件夹拷贝到&#x2F;opt&#x2F;arm-bcm2708下（自定义路径即可）</p>
<p>将上面到交叉编译工具链的路径配置到~&#x2F;.bashrc文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.<span class="property">bashrc</span></span><br><span class="line"><span class="keyword">export</span> <span class="variable constant_">PATH</span>=<span class="attr">$PATH</span>:<span class="regexp">/opt/</span>arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin</span><br></pre></td></tr></table></figure>

<h2 id="4-测试交叉编译工具链是否安装成功"><a href="#4-测试交叉编译工具链是否安装成功" class="headerlink" title="4.测试交叉编译工具链是否安装成功"></a>4.测试交叉编译工具链是否安装成功</h2><p>输入以下指令，如果有打印一些版本信息，那么说明交叉编译环境配置正确<br>arm-linux-gnueabihf-gcc -v<br>如图:<br><img src="/images/4b_succeed.jpg" alt="4b_succeed"></p>
<h2 id="5-假如第4步的时候有报错没有这个文件或目录，但实际是有这个文件的，可以apt-get安装libc6-dev-i386"><a href="#5-假如第4步的时候有报错没有这个文件或目录，但实际是有这个文件的，可以apt-get安装libc6-dev-i386" class="headerlink" title="5.假如第4步的时候有报错没有这个文件或目录，但实际是有这个文件的，可以apt-get安装libc6-dev-i386"></a>5.假如第4步的时候有报错没有这个文件或目录，但实际是有这个文件的，可以apt-get安装libc6-dev-i386</h2><p>如果报错提醒如下：<br><img src="/images/4b_fail_env.jpg" alt="4b_fail_env"></p>
<p>可以按照以下的解决方案尝试一下：<br><img src="/images/4b_deal_fail.jpg" alt="4b_deal_fail"></p>
<p>然后重新输入arm-linux-gnueabihf-gcc -v即可发现打印版本信息</p>
<h2 id="6-编写测试demo，然后编译生成执行文件"><a href="#6-编写测试demo，然后编译生成执行文件" class="headerlink" title="6.编写测试demo，然后编译生成执行文件"></a>6.编写测试demo，然后编译生成执行文件</h2><p>demo略，编译的指令如下：<br><img src="/images/4b_hello_world.jpg" alt="4b_hello_world"></p>
<p>需要注意的是，该可运行文件不能在PC机上运行，只能在树莓派arm板子上运行</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此为止，虚拟机上的树莓派arm的交叉编译工具链搭建完成,这个官方的交叉编译工具链还是很靠谱的</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>下载镜像参考以下网址<br><a href="https://www.jianshu.com/p/1a65cb0b8f58">https://www.jianshu.com/p/1a65cb0b8f58</a><br>下载安装交叉编译链参考以下网址<br><a href="https://www.cnblogs.com/zfyouxi/p/3831769.html">https://www.cnblogs.com/zfyouxi/p/3831769.html</a></p>
]]></content>
      <categories>
        <category>交叉编译</category>
      </categories>
      <tags>
        <tag>交叉编译</tag>
        <tag>raspberrypi</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派64位系统配置32位运行环境</title>
    <url>/posts/9b05f215.html</url>
    <content><![CDATA[<h1 id="树莓派64位系统配置32位运行环境"><a href="#树莓派64位系统配置32位运行环境" class="headerlink" title="树莓派64位系统配置32位运行环境"></a>树莓派64位系统配置32位运行环境</h1><h2 id="配置libc6-armhf"><a href="#配置libc6-armhf" class="headerlink" title="配置libc6:armhf"></a>配置libc6:armhf</h2><p>树莓派本身安装了64位系统的情况下，需要配置32位程序的运行环境，首先安装依赖库，操作步骤如下，以下操作都要在<code>root</code>用户下进行<br><img src="/images/4b_armhf.jpg" alt="4b_armhf"></p>
<h2 id="配置32位程序的依赖库环境"><a href="#配置32位程序的依赖库环境" class="headerlink" title="配置32位程序的依赖库环境"></a>配置32位程序的依赖库环境</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/raspberrypi/tools.git</span><br></pre></td></tr></table></figure>

<p>将<code>arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/</code>路径下的<code>lib</code>库都拷贝到<code>/usr/local/lib32</code>路径下，这个路径可以自己创建，自定义路径名，专门用来存放底层32位依赖库(如libstdc++.so.6)</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实最重要的，就是从官方提供的交叉编译工具链，把32位库给获取到，然后放到树莓派的自定义路径下，之后自己编译的32位执行程序&#x2F;库，都要指定链接这个路径的基础库，否则会报错（找不到依赖库）</p>
<p>本身64位的树莓派系统是不带32位基础库的，所以必须从官方的交叉编译工具链里获取（目前，无法通过<code>apt-get</code>直接获取到所有的32位依赖库）</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://raspberrypi.club/148.html">https://raspberrypi.club/148.html</a></p>
]]></content>
      <categories>
        <category>交叉编译</category>
      </categories>
      <tags>
        <tag>交叉编译</tag>
        <tag>raspberrypi</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派交叉编译的三种常见方式</title>
    <url>/posts/8b97d069.html</url>
    <content><![CDATA[<h1 id="树莓派交叉编译的三种常见方式"><a href="#树莓派交叉编译的三种常见方式" class="headerlink" title="树莓派交叉编译的三种常见方式"></a>树莓派交叉编译的三种常见方式</h1><p><img src="/images/4b_complie_1.jpg" alt="4b_complie_1.jpg"><br><img src="/images/4b_complie_2.jpg" alt="4b_complie_2.jpg"><br><img src="/images/4b_complie_3.jpg" alt="4b_complie_3.jpg"><br><img src="/images/4b_complie_5.jpg" alt="4b_complie_5.jpg"></p>
]]></content>
      <categories>
        <category>交叉编译</category>
      </categories>
      <tags>
        <tag>交叉编译</tag>
        <tag>raspberrypi</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派配置基础环境-ssh-root-静态ip</title>
    <url>/posts/beb88453.html</url>
    <content><![CDATA[<h1 id="树莓派配置基础环境-ssh-root-静态ip"><a href="#树莓派配置基础环境-ssh-root-静态ip" class="headerlink" title="树莓派配置基础环境-ssh-root-静态ip"></a>树莓派配置基础环境-ssh-root-静态ip</h1><h2 id="配置root用户"><a href="#配置root用户" class="headerlink" title="配置root用户"></a>配置root用户</h2><p>在终端进行如下操作即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> passwd root</span><br></pre></td></tr></table></figure>
<p>然后根据提示输入root用户的密码<br>再重复输入一次刚刚设置的密码</p>
<p>切换root用户操作如下即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su -</span><br></pre></td></tr></table></figure>
<p>输入设置的root用户的密码</p>
<h2 id="配置开启ssh"><a href="#配置开启ssh" class="headerlink" title="配置开启ssh"></a>配置开启ssh</h2><p>操作如下即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/ssh/sshd-config</span><br></pre></td></tr></table></figure>
<p>修改 <code>PermitRootLogin yes</code><br>然后保存修改<br>然后执行<code>sudo systemctl restart ssh</code><br>再通过<code>ss -tnl</code>查看是否开启成功即可</p>
<h2 id="配置静态ip如下"><a href="#配置静态ip如下" class="headerlink" title="配置静态ip如下"></a>配置静态ip如下</h2><p>在需要无线网络连接的情况下，配置eth0的静态ip如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/network/interfaces</span><br></pre></td></tr></table></figure>

<p>然后再文件里增加以下内容</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet static</span><br><span class="line">address 192.168.0.1 //IP地址</span><br><span class="line">netmask 255.255.255.0 //掩码</span><br></pre></td></tr></table></figure>

<p>然后保存<br>但是此时，如果不设置一下<code>wlan0</code>，那么会发现虽然静态ip设置成功了，但是树莓派却无法联网了<br>所以还要在<code>interfaces</code>文件里追加以下内容</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">auto wlan0</span><br><span class="line">iface wlan0 inet dhcp</span><br><span class="line">wpa_conf /etc/wpa_supplicant/wpa_supplicant.conf</span><br></pre></td></tr></table></figure>
<p>然后保存<br>退出文件<br>重启树莓派即可</p>
<h2 id="如图，配置动态IP"><a href="#如图，配置动态IP" class="headerlink" title="如图，配置动态IP"></a>如图，配置动态IP</h2><p><img src="/images/shu_ip_dhcp.jpg" alt="shu_ip_dhpc"></p>
<h2 id="如图，配置静态IP"><a href="#如图，配置静态IP" class="headerlink" title="如图，配置静态IP"></a>如图，配置静态IP</h2><p><img src="/images/shu_ip_static.jpg" alt="shu_ip_static"></p>
]]></content>
      <categories>
        <category>交叉编译</category>
      </categories>
      <tags>
        <tag>交叉编译</tag>
        <tag>raspberrypi</tag>
      </tags>
  </entry>
  <entry>
    <title>C++迭代器失效陷阱：一次vector反向遍历中的崩溃分析</title>
    <url>/posts/c73fde88.html</url>
    <content><![CDATA[<h1 id="一次vector反向遍历中的崩溃调试经历"><a href="#一次vector反向遍历中的崩溃调试经历" class="headerlink" title="一次vector反向遍历中的崩溃调试经历"></a>一次vector反向遍历中的崩溃调试经历</h1><p>在 C++ 开发中，<code>std::vector</code> 是最常用的容器，但它也是很多“诡异”崩溃的源头。最近在排查一个 MSVC Debug 模式下的崩溃时，遇到了一个经典的 <strong>迭代器失效（Iterator Invalidation）</strong> 问题。</p>
<p>最令人困惑的是：<strong>旧代码里已经提前 <code>reserve</code> 了足够的空间，理论上没有发生内存重新分配（Reallocation），为什么迭代器还是失效了？</strong></p>
<h2 id="问题现象：令人困惑的崩溃"><a href="#问题现象：令人困惑的崩溃" class="headerlink" title="问题现象：令人困惑的崩溃"></a>问题现象：令人困惑的崩溃</h2><p>这段旧代码逻辑大致如下：我们需要反向遍历一个 <code>vector</code>，找到符合条件的元素后，向 <code>vector</code> 尾部添加一个新元素，然后继续使用当前的迭代器处理数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码示例</span></span><br><span class="line">std::vector&lt;Block&gt; blocks;</span><br><span class="line">blocks.<span class="built_in">reserve</span>(<span class="number">1000</span>); <span class="comment">// 预分配充足内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反向遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = blocks.<span class="built_in">rbegin</span>(); it != blocks.<span class="built_in">rend</span>(); ++it) &#123;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;condition) &#123;</span><br><span class="line">        <span class="comment">// 修改当前元素逻辑...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 危险操作：在遍历过程中添加新元素</span></span><br><span class="line">        blocks.<span class="built_in">push_back</span>(newBlock); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 此时blocks.size()只有8，远小于1000</span></span><br><span class="line">        <span class="comment">// 崩溃点：试图访问刚才那个迭代器</span></span><br><span class="line">        <span class="built_in">process</span>(*it); </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段旧代码在<code>linux</code>下运行了上十年。</p>
<p>但是，在跨平台移植到<code>windows</code>上后，在 Visual Studio Debug 模式下，运行到 <code>process(*it)</code> 时直接弹窗崩溃：</p>
<blockquote>
<p><strong>Debug Assertion Failed!</strong></p>
<p>Expression: <strong>can’t decrement invalidated vector iterator</strong></p>
<p>翻译过来就是：“无法对一个已经失效的 vector 迭代器进行减法操作（–）”。</p>
</blockquote>
<h2 id="为什么会崩？"><a href="#为什么会崩？" class="headerlink" title="为什么会崩？"></a>为什么会崩？</h2><p>很多开发者的第一反应是：“可能是 <code>push_back</code> 导致 <code>vector</code> 扩容了，旧内存被释放，所以迭代器失效。”</p>
<p>但是翻看项目代码发现，旧代码里有 <code>blocks.reserve(1000)</code>，已经确保 <code>capacity</code> 远大于 <code>size</code>（崩溃时是<code>size</code>值是8）。但结果依然崩溃。为什么？</p>
<h3 id="1-迭代器失效-≠-内存重分配"><a href="#1-迭代器失效-≠-内存重分配" class="headerlink" title="1. 迭代器失效 ≠ 内存重分配"></a>1. 迭代器失效 ≠ 内存重分配</h3><p>这是最大的误区。虽然内存重分配（Reallocation）<strong>一定会</strong>导致所有迭代器失效，但<strong>即使不发生内存重分配，某些操作依然会让迭代器失效。</strong></p>
<p>根据 C++ 标准：</p>
<blockquote>
<p>如果 <code>push_back</code> 没有导致内存重分配，那么 <code>end()</code>迭代器以及所有指向<strong>尾后位置</strong>的迭代器都会失效。</p>
<p>如果重新<code>reserve()</code>,那么所有迭代器可能失效</p>
</blockquote>
<h3 id="2-反向迭代器的特殊机制"><a href="#2-反向迭代器的特殊机制" class="headerlink" title="2. 反向迭代器的特殊机制"></a>2. 反向迭代器的特殊机制</h3><p>崩溃的核心原因在于代码里使用了 <code>rbegin()</code> &#x2F; <code>rend()</code>。</p>
<p>在 C++ STL 中，反向迭代器<code>std::reverse_iterator</code>本质上是正向迭代器的包装器，其内部实现依赖于end()位置：</p>
<ul>
<li><code>rbegin()</code> 在物理上对应的是 <code>end() - 1</code>。</li>
<li><code>rend()</code> 在物理上对应的是 <code>begin() - 1</code>（虚拟位置）。</li>
</ul>
<p>所以当我们执行 <code>push_back</code> 时：</p>
<ol>
<li>虽然数据还在原来的内存块里（因为之前有 <code>reserve(1000)</code>，当前<code>size</code>是8，所以没有触发内存重新分配）。</li>
<li>但是 <code>vector</code> 的 <strong><code>end()</code> 位置改变了</strong>（因为多了一个元素，尾巴向后移了一位）。</li>
</ol>
<p><strong>由于反向迭代器依赖于 <code>end()</code> 的相对位置，一旦 <code>end()</code> 发生改变，所有基于旧 <code>end()</code> 建立的反向迭代器关系在逻辑上就“错位”了。</strong></p>
<p><strong>所有依赖end()的反向迭代器立即失效</strong></p>
<p><strong>即使内存未重分配，迭代器仍被标记为无效</strong></p>
<h3 id="3-MSVC-Debug-模式的“洁癖”"><a href="#3-MSVC-Debug-模式的“洁癖”" class="headerlink" title="3. MSVC Debug 模式的“洁癖”"></a>3. MSVC Debug 模式的“洁癖”</h3><p>在 Release 模式下，这行代码可能<strong>侥幸</strong>能跑通（这叫未定义行为，Undefined Behavior），因为内存确实没动。但这是未定义行为(UB)，随时可能崩溃或产生错误结果。</p>
<p>但在 Debug 模式下，MSVC 的 STL 实现开启了 <strong>Iterator Debugging</strong>。它维护了一个迭代器版本列表：</p>
<ol>
<li>当你创建 <code>it</code> 时，它记录了 vector 的当前版本。</li>
<li>当你调用 <code>push_back</code> 时，vector 的版本号更新了。</li>
<li>当你再次访问 <code>*it</code> 时，调试器发现 <code>it</code> 的版本号过期失效了，直接断言崩溃，抛出 <code>can&#39;t decrement invalidated vector iterator</code>。</li>
</ol>
<p><strong>这是一种保护机制，提醒你：这段代码逻辑在标准层面上是错误的。</strong></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>既然知道了原因，解决起来就很容易了。核心原则是：<strong>永远不要相信修改容器后的旧迭代器。</strong></p>
<h3 id="方法一：先备份数据"><a href="#方法一：先备份数据" class="headerlink" title="方法一：先备份数据"></a>方法一：先备份数据</h3><p>这是最安全、改动最小的方法。在调用 <code>push_back</code> 之前，把我们需要的数据拷贝一份出来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = blocks.<span class="built_in">rbegin</span>(); it != blocks.<span class="built_in">rend</span>(); ++it) &#123;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;condition) &#123;</span><br><span class="line">        <span class="comment">// 1. 先备份数据！(Safe Copy)</span></span><br><span class="line">        <span class="keyword">auto</span> safeBlock = *it; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 再修改容器 (这一步会让 it 失效)</span></span><br><span class="line">        blocks.<span class="built_in">push_back</span>(newBlock); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 使用备份的数据进行后续操作</span></span><br><span class="line">        <span class="built_in">process</span>(safeBlock); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 立即退出循环或重置迭代器，绝对不要再对 it 做 ++ 操作</span></span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：使用下标索引（最稳健）"><a href="#方法二：使用下标索引（最稳健）" class="headerlink" title="方法二：使用下标索引（最稳健）"></a>方法二：使用下标索引（最稳健）</h3><p>下标（Index）不依赖于迭代器对象，只要不发生内存搬迁（或者你知道搬迁后的新位置），下标永远是数学上的绝对偏移量。<br><strong>索引不受容器修改影响</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 int 索引代替迭代器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = blocks.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (blocks[i].condition) &#123;</span><br><span class="line">        blocks.<span class="built_in">push_back</span>(newBlock);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 即使 push_back 了，blocks[i] 依然指向原来的第 i 个元素</span></span><br><span class="line">        <span class="comment">// 只要没发生扩容导致内存地址变了，这里甚至引用都有效</span></span><br><span class="line">        <span class="comment">// 但最稳妥的还是只读数据</span></span><br><span class="line">        <span class="built_in">process</span>(blocks[i]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="深入理解：vector的内存管理"><a href="#深入理解：vector的内存管理" class="headerlink" title="深入理解：vector的内存管理"></a>深入理解：vector的内存管理</h2><h3 id="容量-capacity-与大小-size"><a href="#容量-capacity-与大小-size" class="headerlink" title="容量(capacity)与大小(size)"></a>容量(capacity)与大小(size)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[vector内存布局]</span><br><span class="line">    B[已用空间 size=3]</span><br><span class="line">    C[预留空间 capacity=8]</span><br><span class="line">    D[空闲空间]</span><br><span class="line">    </span><br><span class="line">    A --&gt;|内存块| B</span><br><span class="line">    B --&gt; C</span><br><span class="line">    C --&gt; D</span><br></pre></td></tr></table></figure>
<ul>
<li><code>reserve()</code>仅影响<code>capacity</code></li>
<li><code>push_back()</code>修改<code>size</code></li>
<li>迭代器失效仅与<code>size</code>变化有关，与<code>capacity</code>无关</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><strong><code>reserve</code> 不能防止迭代器失效</strong>：它只能防止内存重分配，但 <code>push_back</code> 依然会改变容器的逻辑状态（如 <code>end()</code> 位置）。</li>
<li><strong>修改即死刑</strong>：在循环遍历 <code>vector</code> 的过程中，一旦执行了 <code>push_back</code>、<code>insert</code> 或 <code>erase</code>，请默认当前所有的迭代器都已失效。</li>
<li><strong>Debug 报错是好事</strong>：MSVC 的 <code>invalidated vector iterator</code> 报错是在预警，避免将隐患带入生产环境。</li>
<li><strong>先备份，后修改</strong>：修改容器后，永远不要再使用之前的任何迭代器。</li>
<li><strong>反向迭代器特别脆弱</strong>：对容器的任何修改都会使其失效。</li>
<li><strong>优先使用索引</strong>：当需要遍历并修改容器时，索引更安全。</li>
</ol>
<p>迭代器失效是C++中最常见的陷阱之一，特别是在使用容器反向迭代时。<br>在修改容器之前保存数据，而不是依赖迭代器，养成良好的安全编程习惯，可以避免许多难以调试的运行时错误。</p>
<blockquote>
<p>“在C++中，容器和迭代器的关系就像舞伴——其中一方改变动作时，另一方必须重新协调步伐，否则就会踩到对方的脚。”</p>
</blockquote>
<hr>
<p><em>本文由排查真实 Bug 总结而来，希望能帮你少踩一个坑。</em></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>visual studio断点调试之逐过程-逐语句-跳出</title>
    <url>/posts/d085138b.html</url>
    <content><![CDATA[<p>工欲善其事，必先利其器。</p>
<p>关于visual studio的断点调试，一直没弄清楚那3个选项:逐过程，逐语句，跳出这3个都分别是什么含义！每次都是凭感觉来回试。。。现在终于研究明白了！</p>
<h2 id="调试的核心三剑客"><a href="#调试的核心三剑客" class="headerlink" title="调试的核心三剑客"></a>调试的核心三剑客</h2><p>这三个功能是调试的<strong>核心三剑客</strong>，就像看电影时的“快进”、“慢放”和“跳过”。</p>
<p>一定要记住它们的<strong>快捷键（F10, F11, Shift+F11）</strong>，使用的时候效率会提高十倍！<br>（除了这些，还有些常用的的快捷键，比如 F5 是跳过此次命中，继续执行，真正调试的时候用起来都非常方便）</p>
<h2 id="举个例子来说"><a href="#举个例子来说" class="headerlink" title="举个例子来说"></a>举个例子来说</h2><p>我们假设有这样一段代码，此时断点停在 <code>Calculate()</code> 这一行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">Calculate</span>(a, b);  <span class="comment">// &lt;--- 断点停在这里（黄色箭头）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result: %d&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-逐语句-Step-Into"><a href="#1-逐语句-Step-Into" class="headerlink" title="1. 逐语句 (Step Into)"></a>1. 逐语句 (Step Into)</h3><ul>
<li><strong>快捷键</strong>：<strong>F11</strong></li>
<li><strong>含义</strong>：<strong>遇到函数，这就进去。</strong></li>
<li><strong>动作</strong>：如果当前行包含一个函数调用（比如上面的 <code>Calculate</code>），调试器会<strong>进入</strong>该函数的内部，停在函数的第一行。如果不包含函数，就只走下一行。</li>
<li><strong>使用场景</strong>：<ul>
<li>一般当你怀疑 <code>Calculate</code> 函数<strong>内部</strong>有 Bug。</li>
<li>你想看清楚这个函数具体是怎么一步步运算的。</li>
<li><strong>注意</strong>：如果你不小心对 <code>printf</code> 这种系统函数用了 F11，可能会跳进系统库的源码里（看不懂且没必要），这时候就需要用下面的“跳出”了。</li>
</ul>
</li>
</ul>
<h3 id="2-逐过程-Step-Over"><a href="#2-逐过程-Step-Over" class="headerlink" title="2. 逐过程 (Step Over)"></a>2. 逐过程 (Step Over)</h3><ul>
<li><strong>快捷键</strong>：<strong>F10</strong></li>
<li><strong>含义</strong>：<strong>遇到函数，直接跨过去（但会执行它）。</strong></li>
<li><strong>动作</strong>：把整个函数调用当作<strong>一步</strong>。VS 会瞬间把 <code>Calculate</code> 函数跑完，然后黄色箭头停在下一行 <code>printf</code> 上。</li>
<li><strong>使用场景</strong>：<ul>
<li>一般当你确信 <code>Calculate</code> 函数是没问题的（比如是系统自带的）。</li>
<li>你只关心 <code>Calculate</code> 算出来的<strong>返回值</strong>对不对，不想看它里面怎么算的。</li>
<li>用来快速浏览主流程逻辑。</li>
</ul>
</li>
</ul>
<h3 id="3-跳出-Step-Out"><a href="#3-跳出-Step-Out" class="headerlink" title="3. 跳出 (Step Out)"></a>3. 跳出 (Step Out)</h3><ul>
<li><strong>快捷键</strong>：<strong>Shift + F11</strong></li>
<li><strong>含义</strong>：<strong>在这个函数里呆腻了，赶紧跑完回去。</strong></li>
<li><strong>动作</strong>：瞬间执行完<strong>当前函数剩余的所有代码</strong>，然后返回到<strong>调用这个函数的地方</strong>（也就是父函数）。</li>
<li><strong>使用场景</strong>：<ul>
<li>如果你不小心按 F11 进到了一个枯燥的函数（比如构造函数，或者标准库函数），想赶紧出来。</li>
<li>或者你已经看出了当前函数的逻辑没问题，不想再一行行按了，想直接回到上一层继续调试。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a>总结对比</h2><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">快捷键</th>
<th align="left">动作逻辑</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>逐语句 (Into)</strong></td>
<td align="left"><strong>F11</strong></td>
<td align="left"><strong>最细颗粒度</strong>。遇函数就进，查个底朝天。</td>
</tr>
<tr>
<td align="left"><strong>逐过程 (Over)</strong></td>
<td align="left"><strong>F10</strong></td>
<td align="left"><strong>主流程优先</strong>。遇函数不进，直接拿结果。</td>
</tr>
<tr>
<td align="left"><strong>跳出 (Out)</strong></td>
<td align="left"><strong>Shift+F11</strong></td>
<td align="left"><strong>立即结束当前层</strong>。跑完当前函数，回到上一层。</td>
</tr>
</tbody></table>
<hr>
<h2 id="还从网上学了一个超好用的神技：运行到光标处-Run-to-Cursor"><a href="#还从网上学了一个超好用的神技：运行到光标处-Run-to-Cursor" class="headerlink" title="还从网上学了一个超好用的神技：运行到光标处 (Run to Cursor)"></a>还从网上学了一个超好用的神技：运行到光标处 (Run to Cursor)</h2><ul>
<li><strong>快捷键</strong>：<strong>Ctrl + F10</strong> （或者鼠标右键 -&gt; 运行到光标处）</li>
<li><strong>场景</strong>：<br>你现在在第 10 行，你想看第 50 行的状态。<ul>
<li>如果一直按 F10，手都按酸了。</li>
<li>你可以直接把鼠标点在第 50 行，按 <strong>Ctrl + F10</strong>。</li>
<li>程序会自动全速运行，直到撞上第 50 行才停下（相当于临时加了个断点并运行）。</li>
<li>而且它完全支持跨方法、跨类、跨文件。只要程序的执行流在逻辑上能走到那一行，它就能在那停下来。</li>
<li>另外：如果是鼠标流，Visual Studio 新版本引入了一个更直观的功能：当你把鼠标悬停在代码行号左侧时，会出现一个小小的绿色三角形图标（有时候叫 “Run to here” 图标）。点击这个绿色小箭头，效果和 Ctrl + F10 是一模一样的。这对于不喜欢记快捷键的人来说也很方便。</li>
</ul>
</li>
</ul>
<p>参考资料：<br><a href="https://www.cnblogs.com/weizhixiang/p/6123211.html">https://www.cnblogs.com/weizhixiang/p/6123211.html</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>visual studio</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
</search>
